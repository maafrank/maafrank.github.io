<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://fonts.googleapis.com/css?family=Poppins:100,200,300,400,500,600,700,800,900&amp;subset=devanagari,latin-ext" rel="stylesheet">
    <title>Lesson 3: Time Series Analysis - Quantitative Trading Course</title>
    <link rel="shortcut icon" type="image/icon" href="../../assets/logo/favicon.png"/>
    <link rel="stylesheet" href="../../assets/css/font-awesome.min.css">
    <link rel="stylesheet" href="../../assets/css/bootstrap.min.css">
    <link rel="stylesheet" href="../../assets/css/bootsnav.css">	
    <link rel="stylesheet" href="../../assets/css/style.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <style>
      .lesson-container { min-height: 100vh; background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); padding: 30px 0; }
      .lesson-header { text-align: center; color: #333; margin-bottom: 40px; padding: 40px 0; background: white; box-shadow: 0 2px 10px rgba(0,0,0,0.1); border-radius: 15px; }
      .lesson-header h1 { font-size: 2.8rem; margin-bottom: 15px; color: #28a745; }
      .lesson-header .lesson-meta { display: flex; justify-content: center; gap: 30px; flex-wrap: wrap; margin-top: 20px; font-size: 1rem; color: #666; }
      .back-link { position: absolute; top: 20px; left: 20px; color: #28a745; font-size: 1.2rem; text-decoration: none; transition: all 0.3s ease; z-index: 10; }
      .back-link:hover { color: #1e7e34; text-decoration: none; }
      .lesson-content { background: white; border-radius: 15px; padding: 40px; box-shadow: 0 5px 20px rgba(0,0,0,0.1); margin-bottom: 30px; }
      .lesson-content h2 { color: #28a745; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 3px solid #f0f2f5; }
      .lesson-content h3 { color: #333; margin: 25px 0 15px 0; }
      .lesson-content p { line-height: 1.8; color: #555; margin-bottom: 20px; }
      .code-section { background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; padding: 30px; border-radius: 15px; margin: 30px 0; }
      .code-example { background: #2d3748; border-radius: 10px; padding: 20px; margin: 20px 0; overflow-x: auto; }
      .code-example pre { margin: 0; background: none !important; padding: 0 !important; }
      .code-example code { color: #e2e8f0; font-family: 'Courier New', monospace; font-size: 0.9rem; }
      .output-box { background: #1a202c; color: #e2e8f0; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #4299e1; }
      .exercise-box { background: #e8f4fd; border-left: 4px solid #007bff; padding: 25px; border-radius: 10px; margin: 30px 0; }
      .exercise-box h3 { color: #007bff; margin-bottom: 20px; }
      .ts-info { background: #d4edda; border-left: 4px solid #28a745; padding: 25px; border-radius: 10px; margin: 30px 0; }
      .ts-info h3 { color: #28a745; margin-bottom: 20px; }
      .navigation-buttons { display: flex; justify-content: space-between; margin-top: 40px; flex-wrap: wrap; gap: 15px; }
      .btn-nav { padding: 12px 25px; border-radius: 25px; text-decoration: none; font-weight: 600; transition: all 0.3s ease; border: none; cursor: pointer; }
      .btn-primary { background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; }
      .btn-primary:hover { color: white; text-decoration: none; box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4); }
      .btn-secondary { background: #6c757d; color: white; }
      .btn-secondary:hover { background: #5a6268; color: white; text-decoration: none; }
      .model-comparison { background: #fff3cd; border-left: 4px solid #ffc107; padding: 25px; border-radius: 10px; margin: 30px 0; }
      .model-comparison h3 { color: #856404; margin-bottom: 20px; }
      .forecast-box { background: #f8d7da; border-left: 4px solid #dc3545; padding: 20px; border-radius: 8px; margin: 20px 0; }
      .forecast-box h4 { color: #721c24; margin-bottom: 10px; }
      .method-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin: 20px 0; }
      .method-card { background: #f8f9fa; padding: 20px; border-radius: 10px; border-left: 4px solid #28a745; }
      .method-card h4 { color: #28a745; margin-bottom: 15px; }
    </style>
  </head>
  
  <body>
    <a href="../quant-course.html" class="back-link"><i class="fa fa-arrow-left"></i> Back to Course</a>
    
    <div class="lesson-container">
      <div class="container">
        <div class="lesson-header">
          <h1><i class="fa fa-trending-up"></i> Time Series Analysis</h1>
          <p>Predict future price movements using advanced statistical and ML techniques</p>
          <div class="lesson-meta">
            <span><i class="fa fa-clock-o"></i> 75-90 minutes</span>
            <span><i class="fa fa-bar-chart"></i> Advanced Level</span>
            <span><i class="fa fa-magic"></i> Predictive Modeling</span>
          </div>
        </div>

        <div class="lesson-content">
          <h2>Understanding Time Series in Finance</h2>
          <p>Financial time series analysis is the backbone of quantitative trading. Unlike traditional data analysis, time series data has temporal dependencies where past values influence future ones. This lesson will teach you to harness these patterns for profitable trading strategies.</p>
          
          <div class="ts-info">
            <h3><i class="fa fa-info-circle"></i> Key Time Series Concepts</h3>
            <ul>
              <li><strong>Stationarity:</strong> Statistical properties don't change over time</li>
              <li><strong>Autocorrelation:</strong> Correlation between observations at different time lags</li>
              <li><strong>Seasonality:</strong> Regular patterns that repeat over fixed periods</li>
              <li><strong>Trend:</strong> Long-term directional movement in the data</li>
              <li><strong>Volatility Clustering:</strong> Periods of high/low volatility tend to cluster</li>
              <li><strong>Mean Reversion:</strong> Tendency for prices to return to their historical average</li>
            </ul>
          </div>

          <h2>Setting Up Advanced Time Series Environment</h2>
          <p>Let's prepare our environment with specialized libraries for time series analysis and forecasting.</p>
          
          <div class="code-section">
            <h3>ðŸ”§ Time Series Analysis Setup</h3>
            <div class="code-example">
              <pre><code class="language-python"># Install required packages
# pip install yfinance pandas numpy matplotlib seaborn plotly
# pip install statsmodels scikit-learn arch
# pip install pmdarima tensorflow keras

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Time series specific libraries
import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller, kpss
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.statespace.sarimax import SARIMAX
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

# Machine learning
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error
from sklearn.ensemble import RandomForestRegressor
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

# Volatility modeling
from arch import arch_model

# Warnings
import warnings
warnings.filterwarnings('ignore')

# Set random seeds for reproducibility
np.random.seed(42)
tf.random.set_seed(42)

print("Time Series Analysis Environment Ready!")
print("All libraries loaded successfully")

# Configure plotting
plt.style.use('seaborn-v0_8')
plt.rcParams['figure.figsize'] = (12, 8)</code></pre>
            </div>
            
            <div class="output-box">
              <strong>Expected Output:</strong><br>
              Time Series Analysis Environment Ready!<br>
              All libraries loaded successfully
            </div>
          </div>

          <h2>Data Preparation for Time Series Analysis</h2>
          <p>Proper data preparation is crucial for time series modeling. Let's fetch and prepare our financial data.</p>

          <div class="code-example">
            <pre><code class="language-python"># Enhanced data fetching for time series analysis
def get_financial_time_series(symbol, period="2y", interval="1d"):
    """
    Fetch and prepare financial time series data
    """
    print(f"Fetching {symbol} data for time series analysis...")
    
    # Get stock data
    stock = yf.Ticker(symbol)
    data = stock.history(period=period, interval=interval)
    
    if data.empty:
        print(f"âŒ No data available for {symbol}")
        return None
    
    # Calculate returns and log returns
    data['Returns'] = data['Close'].pct_change()
    data['Log_Returns'] = np.log(data['Close'] / data['Close'].shift(1))
    
    # Calculate volatility (rolling standard deviation)
    data['Volatility'] = data['Returns'].rolling(window=20).std() * np.sqrt(252)
    
    # Price transformations
    data['Log_Price'] = np.log(data['Close'])
    data['Price_Diff'] = data['Close'].diff()
    
    # Technical indicators for features
    data['SMA_20'] = data['Close'].rolling(window=20).mean()
    data['SMA_50'] = data['Close'].rolling(window=50).mean()
    data['RSI'] = calculate_rsi_simple(data['Close'])
    
    # Remove NaN values
    data = data.dropna()
    
    print(f"âœ… Prepared {len(data)} observations")
    print(f"Date range: {data.index[0].date()} to {data.index[-1].date()}")
    
    return data

def calculate_rsi_simple(prices, period=14):
    """Calculate RSI for feature engineering"""
    delta = prices.diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    rs = gain / loss
    return 100 - (100 / (1 + rs))

# Fetch Apple stock data
symbol = "AAPL"
data = get_financial_time_series(symbol, period="2y")

# Display basic time series properties
print(f"\n=== {symbol} Time Series Properties ===")
print(f"Total observations: {len(data)}")
print(f"Average daily return: {data['Returns'].mean()*100:.3f}%")
print(f"Return volatility: {data['Returns'].std()*100:.3f}%")
print(f"Annualized volatility: {data['Returns'].std()*np.sqrt(252)*100:.1f}%")
print(f"Sharpe ratio: {data['Returns'].mean()/data['Returns'].std()*np.sqrt(252):.2f}")

# Show data structure
print(f"\n=== Data Structure ===")
print(data[['Close', 'Returns', 'Log_Returns', 'Volatility']].head(10))</code></pre>
          </div>

          <h2>Time Series Decomposition</h2>
          <p>Understanding the components of a time series helps us identify patterns and choose appropriate modeling techniques.</p>

          <div class="code-example">
            <pre><code class="language-python"># Time series decomposition
def analyze_time_series_components(data, symbol, column='Close'):
    """
    Decompose time series into trend, seasonal, and residual components
    """
    print(f"Analyzing time series components for {symbol}...")
    
    # Perform seasonal decomposition
    # Note: For daily financial data, we'll use a weekly cycle (5 days)
    decomposition = seasonal_decompose(data[column], model='multiplicative', period=5)
    
    # Create decomposition plot
    fig, axes = plt.subplots(4, 1, figsize=(15, 12))
    
    # Original series
    axes[0].plot(data.index, data[column], color='blue', linewidth=1)
    axes[0].set_title(f'{symbol} Original Price Series')
    axes[0].set_ylabel('Price ($)')
    axes[0].grid(True, alpha=0.3)
    
    # Trend
    axes[1].plot(decomposition.trend.index, decomposition.trend, color='red', linewidth=2)
    axes[1].set_title('Trend Component')
    axes[1].set_ylabel('Trend')
    axes[1].grid(True, alpha=0.3)
    
    # Seasonal
    axes[2].plot(decomposition.seasonal.index, decomposition.seasonal, color='green', linewidth=1)
    axes[2].set_title('Seasonal Component')
    axes[2].set_ylabel('Seasonal')
    axes[2].grid(True, alpha=0.3)
    
    # Residual
    axes[3].plot(decomposition.resid.index, decomposition.resid, color='orange', linewidth=1)
    axes[3].set_title('Residual Component')
    axes[3].set_ylabel('Residual')
    axes[3].set_xlabel('Date')
    axes[3].grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.show()
    
    # Analyze components
    trend_strength = 1 - (decomposition.resid.var() / (decomposition.trend + decomposition.resid).var())
    seasonal_strength = 1 - (decomposition.resid.var() / (decomposition.seasonal + decomposition.resid).var())
    
    print(f"Trend strength: {trend_strength:.3f}")
    print(f"Seasonal strength: {seasonal_strength:.3f}")
    
    return decomposition

# Perform decomposition
decomposition = analyze_time_series_components(data, symbol)

# Analyze autocorrelation
def plot_autocorrelation_analysis(data, symbol, lags=40):
    """Plot ACF and PACF for autocorrelation analysis"""
    
    fig, axes = plt.subplots(2, 2, figsize=(15, 10))
    
    # Price autocorrelation
    plot_acf(data['Close'].dropna(), lags=lags, ax=axes[0, 0], title=f'{symbol} Price ACF')
    plot_pacf(data['Close'].dropna(), lags=lags, ax=axes[0, 1], title=f'{symbol} Price PACF')
    
    # Returns autocorrelation
    plot_acf(data['Returns'].dropna(), lags=lags, ax=axes[1, 0], title=f'{symbol} Returns ACF')
    plot_pacf(data['Returns'].dropna(), lags=lags, ax=axes[1, 1], title=f'{symbol} Returns PACF')
    
    plt.tight_layout()
    plt.show()

# Plot autocorrelation analysis
print("Analyzing autocorrelation patterns...")
plot_autocorrelation_analysis(data, symbol)</code></pre>
          </div>

          <h2>Stationarity Testing</h2>
          <p>Most time series models require stationary data. Let's test for stationarity and apply transformations if needed.</p>

          <div class="method-grid">
            <div class="method-card">
              <h4>Augmented Dickey-Fuller Test</h4>
              <p>Tests null hypothesis that the series has a unit root (non-stationary)</p>
              <p><strong>Decision:</strong> p-value < 0.05 â†’ Stationary</p>
            </div>
            
            <div class="method-card">
              <h4>KPSS Test</h4>
              <p>Tests null hypothesis that the series is stationary</p>
              <p><strong>Decision:</strong> p-value > 0.05 â†’ Stationary</p>
            </div>
            
            <div class="method-card">
              <h4>Differencing</h4>
              <p>Transform non-stationary series by taking differences</p>
              <p><strong>Method:</strong> Î”y(t) = y(t) - y(t-1)</p>
            </div>
          </div>

          <div class="code-example">
            <pre><code class="language-python"># Stationarity testing functions
def test_stationarity(series, title="Time Series"):
    """
    Perform comprehensive stationarity tests
    """
    print(f"\n=== Stationarity Tests for {title} ===")
    
    # Augmented Dickey-Fuller test
    adf_result = adfuller(series.dropna())
    print(f"ADF Test:")
    print(f"  ADF Statistic: {adf_result[0]:.6f}")
    print(f"  p-value: {adf_result[1]:.6f}")
    print(f"  Critical Values:")
    for key, value in adf_result[4].items():
        print(f"    {key}: {value:.3f}")
    
    adf_stationary = adf_result[1] <= 0.05
    print(f"  ADF Result: {'Stationary' if adf_stationary else 'Non-Stationary'}")
    
    # KPSS test
    try:
        kpss_result = kpss(series.dropna(), regression='c')
        print(f"\nKPSS Test:")
        print(f"  KPSS Statistic: {kpss_result[0]:.6f}")
        print(f"  p-value: {kpss_result[1]:.6f}")
        print(f"  Critical Values:")
        for key, value in kpss_result[3].items():
            print(f"    {key}: {value:.3f}")
        
        kpss_stationary = kpss_result[1] >= 0.05
        print(f"  KPSS Result: {'Stationary' if kpss_stationary else 'Non-Stationary'}")
        
        # Combined conclusion
        if adf_stationary and kpss_stationary:
            conclusion = "Stationary"
        elif not adf_stationary and not kpss_stationary:
            conclusion = "Non-Stationary"
        else:
            conclusion = "Inconclusive (mixed results)"
        
        print(f"\nCombined Conclusion: {conclusion}")
        
    except Exception as e:
        print(f"KPSS test failed: {e}")
        conclusion = "Stationary" if adf_stationary else "Non-Stationary"
        print(f"Conclusion based on ADF only: {conclusion}")
    
    return conclusion

# Test different series for stationarity
print("Testing stationarity for different transformations...")

# Test price levels
price_stationarity = test_stationarity(data['Close'], f"{symbol} Price")

# Test returns
returns_stationarity = test_stationarity(data['Returns'], f"{symbol} Returns")

# Test log returns
log_returns_stationarity = test_stationarity(data['Log_Returns'], f"{symbol} Log Returns")

# Test first difference of prices
price_diff_stationarity = test_stationarity(data['Price_Diff'], f"{symbol} Price Differences")

# Create difference series if needed
if price_stationarity == "Non-Stationary":
    data['Price_Diff2'] = data['Close'].diff().diff()
    price_diff2_stationarity = test_stationarity(data['Price_Diff2'], f"{symbol} Second Difference")

# Summary
print(f"\n=== Stationarity Summary ===")
print(f"Price levels: {price_stationarity}")
print(f"Returns: {returns_stationarity}")
print(f"Log returns: {log_returns_stationarity}")
print(f"Price differences: {price_diff_stationarity}")

# Visualize different transformations
def plot_stationarity_comparison(data, symbol):
    """Plot different transformations for visual comparison"""
    
    fig, axes = plt.subplots(2, 2, figsize=(15, 10))
    
    # Original prices
    axes[0, 0].plot(data.index, data['Close'], color='blue', linewidth=1)
    axes[0, 0].set_title(f'{symbol} Original Prices')
    axes[0, 0].set_ylabel('Price ($)')
    axes[0, 0].grid(True, alpha=0.3)
    
    # Returns
    axes[0, 1].plot(data.index, data['Returns'], color='red', linewidth=1)
    axes[0, 1].set_title(f'{symbol} Returns')
    axes[0, 1].set_ylabel('Returns')
    axes[0, 1].axhline(y=0, color='black', linestyle='--', alpha=0.5)
    axes[0, 1].grid(True, alpha=0.3)
    
    # Log returns
    axes[1, 0].plot(data.index, data['Log_Returns'], color='green', linewidth=1)
    axes[1, 0].set_title(f'{symbol} Log Returns')
    axes[1, 0].set_ylabel('Log Returns')
    axes[1, 0].axhline(y=0, color='black', linestyle='--', alpha=0.5)
    axes[1, 0].grid(True, alpha=0.3)
    
    # Price differences
    axes[1, 1].plot(data.index, data['Price_Diff'], color='orange', linewidth=1)
    axes[1, 1].set_title(f'{symbol} Price Differences')
    axes[1, 1].set_ylabel('Price Difference')
    axes[1, 1].axhline(y=0, color='black', linestyle='--', alpha=0.5)
    axes[1, 1].grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.show()

# Plot transformations
plot_stationarity_comparison(data, symbol)</code></pre>
          </div>

          <h2>ARIMA Modeling</h2>
          <p>ARIMA (AutoRegressive Integrated Moving Average) models are the foundation of time series forecasting in finance.</p>

          <div class="model-comparison">
            <h3><i class="fa fa-cogs"></i> ARIMA Model Components</h3>
            <ul>
              <li><strong>AR(p):</strong> AutoRegressive - uses past values to predict future</li>
              <li><strong>I(d):</strong> Integrated - degree of differencing to achieve stationarity</li>
              <li><strong>MA(q):</strong> Moving Average - uses past forecast errors</li>
            </ul>
          </div>

          <div class="code-section">
            <h3>ðŸ“Š ARIMA Implementation</h3>
            <div class="code-example">
              <pre><code class="language-python"># ARIMA model implementation
def find_optimal_arima_order(series, max_p=5, max_d=2, max_q=5):
    """
    Find optimal ARIMA order using AIC criterion
    """
    print("Searching for optimal ARIMA parameters...")
    
    best_aic = np.inf
    best_order = None
    best_model = None
    
    # Grid search for best parameters
    for p in range(max_p + 1):
        for d in range(max_d + 1):
            for q in range(max_q + 1):
                try:
                    model = ARIMA(series, order=(p, d, q))
                    fitted_model = model.fit()
                    
                    if fitted_model.aic < best_aic:
                        best_aic = fitted_model.aic
                        best_order = (p, d, q)
                        best_model = fitted_model
                        
                except Exception as e:
                    continue
    
    print(f"Best ARIMA order: {best_order}")
    print(f"Best AIC: {best_aic:.2f}")
    
    return best_order, best_model

# Find optimal ARIMA model for returns
print("Building ARIMA model for returns...")
best_order, arima_model = find_optimal_arima_order(data['Returns'].dropna(), max_p=3, max_d=1, max_q=3)

# Print model summary
print("\n=== ARIMA Model Summary ===")
print(arima_model.summary())

# Generate forecasts
def generate_arima_forecast(model, steps=30):
    """Generate ARIMA forecasts with confidence intervals"""
    
    forecast = model.forecast(steps=steps)
    conf_int = model.get_forecast(steps=steps).conf_int()
    
    return forecast, conf_int

# Generate 30-day forecast
forecast, conf_int = generate_arima_forecast(arima_model, steps=30)

print(f"\n=== ARIMA Forecast (Next 30 days) ===")
print("Forecasted returns:")
for i, value in enumerate(forecast[:10]):
    print(f"Day {i+1}: {value:.4f}")

# Plot ARIMA results
def plot_arima_results(data, model, forecast, conf_int, symbol, days_to_show=100):
    """Plot ARIMA model results and forecasts"""
    
    # Get recent data for plotting
    recent_data = data['Returns'].dropna().tail(days_to_show)
    
    # Create forecast dates
    last_date = data.index[-1]
    forecast_dates = pd.date_range(start=last_date + pd.Timedelta(days=1), periods=len(forecast), freq='D')
    
    # Plot
    plt.figure(figsize=(15, 8))
    
    # Historical data
    plt.plot(recent_data.index, recent_data, label='Historical Returns', color='blue', linewidth=1)
    
    # Forecast
    plt.plot(forecast_dates, forecast, label='ARIMA Forecast', color='red', linewidth=2)
    
    # Confidence intervals
    plt.fill_between(forecast_dates, conf_int.iloc[:, 0], conf_int.iloc[:, 1], 
                    color='red', alpha=0.2, label='Confidence Interval')
    
    plt.title(f'{symbol} ARIMA{best_order} Returns Forecast')
    plt.xlabel('Date')
    plt.ylabel('Returns')
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.axhline(y=0, color='black', linestyle='--', alpha=0.5)
    
    plt.tight_layout()
    plt.show()

# Plot ARIMA results
plot_arima_results(data, arima_model, forecast, conf_int, symbol)

# Model diagnostics
def plot_arima_diagnostics(model):
    """Plot ARIMA model diagnostics"""
    
    residuals = model.resid
    
    fig, axes = plt.subplots(2, 2, figsize=(15, 10))
    
    # Residuals plot
    residuals.plot(ax=axes[0, 0], title='Residuals')
    axes[0, 0].grid(True, alpha=0.3)
    
    # Residuals histogram
    residuals.hist(ax=axes[0, 1], bins=30, title='Residuals Histogram')
    axes[0, 1].grid(True, alpha=0.3)
    
    # Q-Q plot
    sm.qqplot(residuals, line='s', ax=axes[1, 0])
    axes[1, 0].set_title('Q-Q Plot')
    axes[1, 0].grid(True, alpha=0.3)
    
    # ACF of residuals
    plot_acf(residuals, ax=axes[1, 1], title='ACF of Residuals')
    
    plt.tight_layout()
    plt.show()
    
    # Ljung-Box test for residual autocorrelation
    lb_stat, lb_pvalue = sm.stats.diagnostic.acorr_ljungbox(residuals, lags=10, return_df=False)[:2]
    print(f"Ljung-Box test p-value: {lb_pvalue:.4f}")
    print(f"Residuals {'appear to be' if lb_pvalue > 0.05 else 'may not be'} white noise")

# Run diagnostics
print("Running ARIMA model diagnostics...")
plot_arima_diagnostics(arima_model)</code></pre>
            </div>
          </div>

          <h2>GARCH Volatility Modeling</h2>
          <p>GARCH models capture volatility clustering - a key characteristic of financial time series where periods of high volatility are followed by high volatility.</p>

          <div class="code-example">
            <pre><code class="language-python"># GARCH volatility modeling
def build_garch_model(returns, p=1, q=1):
    """
    Build and fit GARCH model for volatility forecasting
    """
    print(f"Building GARCH({p},{q}) model...")
    
    # Remove any remaining NaN values
    clean_returns = returns.dropna() * 100  # Convert to percentage for better numerical stability
    
    # Define GARCH model
    garch_model = arch_model(clean_returns, vol='GARCH', p=p, q=q, rescale=False)
    
    # Fit the model
    garch_fitted = garch_model.fit(disp='off')
    
    print("GARCH model fitted successfully!")
    return garch_fitted

# Fit GARCH model
garch_model = build_garch_model(data['Returns'])

# Print GARCH summary
print("\n=== GARCH Model Summary ===")
print(garch_model.summary())

# Generate volatility forecasts
def forecast_volatility(garch_model, horizon=30):
    """Generate GARCH volatility forecasts"""
    
    volatility_forecast = garch_model.forecast(horizon=horizon)
    
    return volatility_forecast

# Generate volatility forecast
vol_forecast = forecast_volatility(garch_model, horizon=30)

print(f"\n=== GARCH Volatility Forecast ===")
print("Forecasted volatility (next 10 days):")
for i in range(10):
    vol_value = np.sqrt(vol_forecast.variance.iloc[-1, i])
    print(f"Day {i+1}: {vol_value:.3f}%")

# Plot GARCH results
def plot_garch_results(data, garch_model, vol_forecast, symbol):
    """Plot GARCH volatility modeling results"""
    
    # Extract conditional volatility
    cond_vol = garch_model.conditional_volatility
    
    fig, axes = plt.subplots(3, 1, figsize=(15, 12))
    
    # Returns
    axes[0].plot(data.index, data['Returns'] * 100, label='Returns', linewidth=1, alpha=0.7)
    axes[0].set_title(f'{symbol} Returns')
    axes[0].set_ylabel('Returns (%)')
    axes[0].grid(True, alpha=0.3)
    axes[0].legend()
    
    # Conditional volatility
    vol_dates = data.index[-len(cond_vol):]
    axes[1].plot(vol_dates, cond_vol, label='GARCH Volatility', color='red', linewidth=2)
    axes[1].set_title('GARCH Conditional Volatility')
    axes[1].set_ylabel('Volatility (%)')
    axes[1].grid(True, alpha=0.3)
    axes[1].legend()
    
    # Squared returns vs fitted volatility
    squared_returns = (data['Returns'] * 100) ** 2
    axes[2].plot(vol_dates, squared_returns.iloc[-len(cond_vol):], 
                label='Squared Returns', alpha=0.6, linewidth=1)
    axes[2].plot(vol_dates, cond_vol ** 2, 
                label='GARCH Variance', color='red', linewidth=2)
    axes[2].set_title('Squared Returns vs GARCH Variance')
    axes[2].set_ylabel('Variance')
    axes[2].set_xlabel('Date')
    axes[2].grid(True, alpha=0.3)
    axes[2].legend()
    
    plt.tight_layout()
    plt.show()

# Plot GARCH results
plot_garch_results(data, garch_model, vol_forecast, symbol)</code></pre>
          </div>

          <h2>Machine Learning for Time Series</h2>
          <p>Modern ML techniques can capture complex non-linear patterns in financial time series that traditional models might miss.</p>

          <div class="code-section">
            <h3>ðŸ¤– LSTM Neural Networks</h3>
            <div class="code-example">
              <pre><code class="language-python"># LSTM implementation for time series forecasting
def prepare_lstm_data(data, target_col='Close', lookback=60, forecast_horizon=1):
    """
    Prepare data for LSTM training
    """
    print(f"Preparing LSTM data with {lookback} lookback period...")
    
    # Select features
    feature_cols = [target_col, 'Volume', 'SMA_20', 'SMA_50', 'RSI']
    df = data[feature_cols].dropna().copy()
    
    # Scale the data
    scaler = MinMaxScaler()
    scaled_data = scaler.fit_transform(df)
    
    # Create sequences
    X, y = [], []
    for i in range(lookback, len(scaled_data) - forecast_horizon + 1):
        X.append(scaled_data[i-lookback:i])
        y.append(scaled_data[i + forecast_horizon - 1, 0])  # Predict target_col
    
    X, y = np.array(X), np.array(y)
    
    print(f"Created {len(X)} sequences")
    print(f"Input shape: {X.shape}")
    print(f"Output shape: {y.shape}")
    
    return X, y, scaler

# Prepare LSTM data
X, y, scaler = prepare_lstm_data(data, target_col='Close', lookback=60)

# Split data
train_size = int(len(X) * 0.8)
X_train, X_test = X[:train_size], X[train_size:]
y_train, y_test = y[:train_size], y[train_size:]

print(f"Training samples: {len(X_train)}")
print(f"Testing samples: {len(X_test)}")

# Build LSTM model
def build_lstm_model(input_shape):
    """Build LSTM model architecture"""
    
    model = Sequential([
        LSTM(50, return_sequences=True, input_shape=input_shape),
        Dropout(0.2),
        LSTM(50, return_sequences=True),
        Dropout(0.2),
        LSTM(50),
        Dropout(0.2),
        Dense(25),
        Dense(1)
    ])
    
    model.compile(optimizer='adam', loss='mse', metrics=['mae'])
    return model

# Build model
lstm_model = build_lstm_model((X_train.shape[1], X_train.shape[2]))
print("\nLSTM Model Architecture:")
lstm_model.summary()

# Train LSTM model
print("\nTraining LSTM model...")
history = lstm_model.fit(
    X_train, y_train,
    epochs=50,
    batch_size=32,
    validation_split=0.2,
    verbose=1,
    callbacks=[
        tf.keras.callbacks.EarlyStopping(patience=10, restore_best_weights=True),
        tf.keras.callbacks.ReduceLROnPlateau(factor=0.5, patience=5)
    ]
)

# Plot training history
def plot_training_history(history):
    """Plot LSTM training history"""
    
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5))
    
    # Loss
    ax1.plot(history.history['loss'], label='Training Loss')
    ax1.plot(history.history['val_loss'], label='Validation Loss')
    ax1.set_title('Model Loss')
    ax1.set_xlabel('Epoch')
    ax1.set_ylabel('Loss')
    ax1.legend()
    ax1.grid(True, alpha=0.3)
    
    # MAE
    ax2.plot(history.history['mae'], label='Training MAE')
    ax2.plot(history.history['val_mae'], label='Validation MAE')
    ax2.set_title('Model MAE')
    ax2.set_xlabel('Epoch')
    ax2.set_ylabel('MAE')
    ax2.legend()
    ax2.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.show()

plot_training_history(history)

# Make predictions
print("Generating LSTM predictions...")
y_pred = lstm_model.predict(X_test)

# Inverse transform predictions
def inverse_transform_predictions(predictions, scaler):
    """Inverse transform scaled predictions"""
    # Create dummy array with same shape as original features
    dummy = np.zeros((len(predictions), scaler.n_features_in_))
    dummy[:, 0] = predictions.flatten()
    
    # Inverse transform
    inversed = scaler.inverse_transform(dummy)
    return inversed[:, 0]

y_pred_actual = inverse_transform_predictions(y_pred, scaler)
y_test_actual = inverse_transform_predictions(y_test, scaler)

# Calculate metrics
mse = mean_squared_error(y_test_actual, y_pred_actual)
mae = mean_absolute_error(y_test_actual, y_pred_actual)
rmse = np.sqrt(mse)

print(f"\n=== LSTM Model Performance ===")
print(f"MSE: {mse:.4f}")
print(f"MAE: {mae:.4f}")
print(f"RMSE: {rmse:.4f}")

# Directional accuracy
actual_direction = np.sign(np.diff(y_test_actual))
pred_direction = np.sign(np.diff(y_pred_actual))
directional_accuracy = np.mean(actual_direction == pred_direction)
print(f"Directional Accuracy: {directional_accuracy:.4f}")

# Plot LSTM predictions
def plot_lstm_predictions(y_test, y_pred, symbol, days_to_show=100):
    """Plot LSTM predictions vs actual values"""
    
    # Limit to recent data for clarity
    if len(y_test) > days_to_show:
        y_test_plot = y_test[-days_to_show:]
        y_pred_plot = y_pred[-days_to_show:]
    else:
        y_test_plot = y_test
        y_pred_plot = y_pred
    
    plt.figure(figsize=(15, 8))
    plt.plot(y_test_plot, label='Actual Prices', linewidth=2)
    plt.plot(y_pred_plot, label='LSTM Predictions', linewidth=2, alpha=0.8)
    plt.title(f'{symbol} LSTM Price Predictions')
    plt.xlabel('Time Steps')
    plt.ylabel('Price ($)')
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()

plot_lstm_predictions(y_test_actual, y_pred_actual, symbol)</code></pre>
            </div>
          </div>

          <div class="exercise-box">
            <h3><i class="fa fa-code"></i> Hands-On Exercise</h3>
            <p>Apply time series analysis to build your own forecasting models!</p>
            
            <h4>Exercise 1: Multi-Model Comparison</h4>
            <p>Compare different forecasting approaches:</p>
            <ul>
              <li>Build ARIMA, GARCH, and LSTM models for the same stock</li>
              <li>Compare their forecasting accuracy</li>
              <li>Analyze which model performs better in different market conditions</li>
              <li>Create an ensemble prediction combining all models</li>
            </ul>
            
            <div class="code-example">
              <pre><code class="language-python"># Your multi-model comparison
def compare_forecasting_models(data, symbol, test_size=50):
    """
    Compare ARIMA, GARCH, and LSTM forecasting performance
    """
    
    # Split data
    train_data = data[:-test_size]
    test_data = data[-test_size:]
    
    results = {}
    
    # ARIMA Model
    print("Building ARIMA model...")
    # Your ARIMA implementation here
    
    # GARCH Model  
    print("Building GARCH model...")
    # Your GARCH implementation here
    
    # LSTM Model
    print("Building LSTM model...")
    # Your LSTM implementation here
    
    # Ensemble Model
    print("Creating ensemble predictions...")
    # Your ensemble implementation here
    
    # Compare performance
    # Your comparison code here
    
    return results

# Test your comparison
# comparison_results = compare_forecasting_models(data, symbol)</code></pre>
            </div>
            
            <h4>Exercise 2: Trading Strategy Based on Forecasts</h4>
            <p>Build a trading strategy using your time series forecasts:</p>
            
            <div class="code-example">
              <pre><code class="language-python"># Time series-based trading strategy
def create_forecast_strategy(data, model, lookback=30):
    """
    Create trading signals based on time series forecasts
    """
    
    signals = pd.DataFrame(index=data.index)
    signals['Signal'] = 0
    
    # Your strategy logic here:
    # 1. Generate rolling forecasts
    # 2. Compare forecast vs current price
    # 3. Generate buy/sell signals
    # 4. Add risk management rules
    
    return signals

# Implement and test your strategy
# strategy_signals = create_forecast_strategy(data, lstm_model)

# Backtest the strategy
# Your backtesting code here</code></pre>
            </div>
          </div>

          <div class="forecast-box">
            <h4><i class="fa fa-exclamation-triangle"></i> Forecasting Limitations</h4>
            <ul>
              <li><strong>Uncertainty:</strong> Financial markets are inherently unpredictable</li>
              <li><strong>Model Risk:</strong> All models are simplifications of reality</li>
              <li><strong>Regime Changes:</strong> Market conditions can change suddenly</li>
              <li><strong>Overfitting:</strong> Complex models may not generalize well</li>
              <li><strong>Data Quality:</strong> Forecasts are only as good as the input data</li>
            </ul>
          </div>

          <h2>Key Takeaways</h2>
          <p>You've mastered advanced time series analysis for quantitative trading:</p>
          <ul>
            <li><strong>Time Series Fundamentals:</strong> Stationarity, autocorrelation, and decomposition</li>
            <li><strong>Statistical Models:</strong> ARIMA for price forecasting and GARCH for volatility</li>
            <li><strong>Machine Learning:</strong> LSTM neural networks for complex pattern recognition</li>
            <li><strong>Model Diagnostics:</strong> Testing and validating forecasting models</li>
            <li><strong>Practical Application:</strong> Building trading strategies from forecasts</li>
            <li><strong>Risk Awareness:</strong> Understanding the limitations of forecasting</li>
          </ul>
          
          <p>Next, we'll put these forecasting skills to work by building our first complete momentum trading strategy with machine learning signals!</p>
        </div>

        <div class="navigation-buttons">
          <a href="lesson-2-technical-analysis.html" class="btn-nav btn-secondary">
            <i class="fa fa-arrow-left"></i> Previous: Technical Analysis
          </a>
          <a href="lesson-4-momentum-strategy.html" class="btn-nav btn-primary">
            Next: Momentum Trading Strategy <i class="fa fa-arrow-right"></i>
          </a>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
    
    <script>
      // Mark lesson as completed when user scrolls to bottom
      window.addEventListener('scroll', function() {
        if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight - 100) {
          localStorage.setItem('quant_lesson_3_completed', 'true');
        }
      });
    </script>
  </body>
</html>
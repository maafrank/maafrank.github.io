<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://fonts.googleapis.com/css?family=Poppins:100,200,300,400,500,600,700,800,900&amp;subset=devanagari,latin-ext" rel="stylesheet">
    <title>Lesson 8: Backtesting & Strategy Evaluation - Quantitative Trading Course</title>
    <link rel="shortcut icon" type="image/icon" href="../../assets/logo/favicon.png"/>
    <link rel="stylesheet" href="../../assets/css/font-awesome.min.css">
    <link rel="stylesheet" href="../../assets/css/bootstrap.min.css">
    <link rel="stylesheet" href="../../assets/css/bootsnav.css">	
    <link rel="stylesheet" href="../../assets/css/style.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <style>
      .lesson-container { min-height: 100vh; background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); padding: 30px 0; }
      .lesson-header { text-align: center; color: #333; margin-bottom: 40px; padding: 40px 0; background: white; box-shadow: 0 2px 10px rgba(0,0,0,0.1); border-radius: 15px; }
      .lesson-header h1 { font-size: 2.8rem; margin-bottom: 15px; color: #28a745; }
      .lesson-header .lesson-meta { display: flex; justify-content: center; gap: 30px; flex-wrap: wrap; margin-top: 20px; font-size: 1rem; color: #666; }
      .back-link { position: absolute; top: 20px; left: 20px; color: #28a745; font-size: 1.2rem; text-decoration: none; transition: all 0.3s ease; z-index: 10; }
      .back-link:hover { color: #1e7e34; text-decoration: none; }
      .lesson-content { background: white; border-radius: 15px; padding: 40px; box-shadow: 0 5px 20px rgba(0,0,0,0.1); margin-bottom: 30px; }
      .lesson-content h2 { color: #28a745; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 3px solid #f0f2f5; }
      .lesson-content h3 { color: #333; margin: 25px 0 15px 0; }
      .lesson-content p { line-height: 1.8; color: #555; margin-bottom: 20px; }
      .code-section { background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; padding: 30px; border-radius: 15px; margin: 30px 0; }
      .code-example { background: #2d3748; border-radius: 10px; padding: 20px; margin: 20px 0; overflow-x: auto; }
      .code-example pre { margin: 0; background: none !important; padding: 0 !important; }
      .code-example code { color: #e2e8f0; font-family: 'Courier New', monospace; font-size: 0.9rem; }
      .output-box { background: #1a202c; color: #e2e8f0; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #4299e1; }
      .exercise-box { background: #e8f4fd; border-left: 4px solid #007bff; padding: 25px; border-radius: 10px; margin: 30px 0; }
      .exercise-box h3 { color: #007bff; margin-bottom: 20px; }
      .metrics-info { background: #d4edda; border-left: 4px solid #28a745; padding: 25px; border-radius: 10px; margin: 30px 0; }
      .metrics-info h3 { color: #28a745; margin-bottom: 20px; }
      .navigation-buttons { display: flex; justify-content: space-between; margin-top: 40px; flex-wrap: wrap; gap: 15px; }
      .btn-nav { padding: 12px 25px; border-radius: 25px; text-decoration: none; font-weight: 600; transition: all 0.3s ease; border: none; cursor: pointer; }
      .btn-primary { background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; }
      .btn-primary:hover { color: white; text-decoration: none; box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4); }
      .btn-secondary { background: #6c757d; color: white; }
      .btn-secondary:hover { background: #5a6268; color: white; text-decoration: none; }
      .warning-box { background: #f8d7da; border-left: 4px solid #dc3545; padding: 20px; border-radius: 8px; margin: 20px 0; }
      .warning-box h4 { color: #721c24; margin-bottom: 10px; }
      .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin: 20px 0; }
      .metric-card { background: #f8f9fa; padding: 20px; border-radius: 10px; border-left: 4px solid #28a745; }
      .metric-card h4 { color: #28a745; margin-bottom: 10px; }
      .bias-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin: 20px 0; }
      .bias-card { background: #fff3cd; padding: 20px; border-radius: 10px; border-left: 4px solid #ffc107; }
      .bias-card h4 { color: #856404; margin-bottom: 10px; }
    </style>
  </head>
  
  <body>
    <a href="../quant-course.html" class="back-link"><i class="fa fa-arrow-left"></i> Back to Course</a>
    
    <div class="lesson-container">
      <div class="container">
        <div class="lesson-header">
          <h1><i class="fa fa-line-chart"></i> Backtesting & Strategy Evaluation</h1>
          <p>Master the art of testing and evaluating quantitative trading strategies</p>
          <div class="lesson-meta">
            <span><i class="fa fa-clock-o"></i> 60-75 minutes</span>
            <span><i class="fa fa-bar-chart"></i> Advanced Level</span>
            <span><i class="fa fa-calculator"></i> Performance Metrics</span>
          </div>
        </div>

        <div class="lesson-content">
          <h2>Introduction to Backtesting</h2>
          <p>Backtesting is the process of testing a trading strategy using historical data to evaluate its performance. It's a critical step in quantitative trading that helps us understand how a strategy would have performed in the past and estimate its future potential.</p>
          
          <p>However, backtesting comes with many pitfalls and biases that can lead to overly optimistic results. This lesson will teach you how to backtest properly and avoid common mistakes.</p>
          
          <div class="exercise-box">
            <h3><i class="fa fa-history"></i> Why Professional Firms Obsess Over Backtesting</h3>
            <p><strong>Risk Management Reality:</strong> Before risking a single dollar of client money, professional trading firms backtest strategies across decades of market data, multiple asset classes, and various market regimes. A strategy that looks good in bull markets might destroy capital during bear markets. Backtesting reveals these hidden risks before they become real losses.</p>
            
            <p><strong>Investor Due Diligence:</strong> Institutional investors demand rigorous backtesting before allocating capital. A hedge fund presenting a strategy must show performance across multiple time periods, market conditions, and risk scenarios. Poor backtesting methodology can cost firms billions in lost investment opportunities.</p>
            
            <p><strong>Regulatory Requirements:</strong> Financial regulators require firms to validate their models and risk management systems. Backtesting isn't just best practice - it's often legally required. Firms must prove their risk models accurately predicted actual losses, with regulatory penalties for inadequate testing.</p>
            
            <p><strong>Strategy Development Cycle:</strong> Professional quantitative teams spend 80% of their time on backtesting and validation, 20% on implementation. The most brilliant strategy idea is worthless if it can't survive rigorous historical testing. Backtesting separates profitable strategies from expensive mistakes.</p>
          </div>

          <div class="warning-box">
            <h4><i class="fa fa-exclamation-triangle"></i> Important Disclaimer</h4>
            <p>Past performance does not guarantee future results. Backtesting is a simulation based on historical data and cannot account for all real-world trading conditions. Always validate strategies with paper trading before risking real capital.</p>
          </div>

          <h2>Key Performance Metrics</h2>
          <p>Understanding performance metrics is crucial for evaluating trading strategies objectively.</p>
          
          <div class="metrics-info">
            <h3><i class="fa fa-calculator"></i> The Language of Professional Performance Measurement</h3>
            <p><strong>Sharpe Ratio Supremacy:</strong> The Sharpe ratio is the gold standard of risk-adjusted returns because it answers the question "How much return did I get per unit of risk?" A strategy with 20% returns and 15% volatility (Sharpe = 1.33) is better than one with 30% returns and 40% volatility (Sharpe = 0.75). Professional managers are evaluated on Sharpe ratios, not raw returns.</p>
            
            <p><strong>Maximum Drawdown Reality:</strong> Drawdown measures your worst loss from peak to trough - the real pain investors feel. A 50% drawdown means investors need 100% gains just to break even. Many profitable strategies are abandoned during drawdowns because investors can't psychologically handle the losses, making drawdown management crucial for strategy longevity.</p>
            
            <p><strong>Win Rate Deception:</strong> A 90% win rate sounds impressive, but it's meaningless if the average loss is 10x the average win. Professional traders focus on profit factor (total profits √∑ total losses) and risk-reward ratios. Some of the best strategies have win rates below 50% but massive profit factors.</p>
            
            <p><strong>Calmar Ratio Insight:</strong> This measures annual return relative to maximum drawdown, showing how much return you get for the worst-case scenario risk. It's particularly important for hedge funds and institutional investors who face redemptions during drawdowns.</p>
          </div>

          <div class="metrics-info">
            <h3><i class="fa fa-dashboard"></i> Essential Trading Metrics</h3>
            <div class="metrics-grid">
              <div class="metric-card">
                <h4>üìà Total Return</h4>
                <p><strong>Formula:</strong> (Final Value - Initial Value) / Initial Value</p>
                <p><strong>Use:</strong> Overall profit/loss percentage</p>
                <p><strong>Good:</strong> > 10% annually</p>
              </div>
              
              <div class="metric-card">
                <h4>üìä Sharpe Ratio</h4>
                <p><strong>Formula:</strong> (Strategy Return - Risk-Free Rate) / Strategy Volatility</p>
                <p><strong>Use:</strong> Risk-adjusted returns</p>
                <p><strong>Good:</strong> > 1.0, Excellent: > 2.0</p>
              </div>
              
              <div class="metric-card">
                <h4>üìâ Maximum Drawdown</h4>
                <p><strong>Formula:</strong> (Peak Value - Trough Value) / Peak Value</p>
                <p><strong>Use:</strong> Worst loss from peak to trough</p>
                <p><strong>Good:</strong> < 20%</p>
              </div>
              
              <div class="metric-card">
                <h4>üéØ Win Rate</h4>
                <p><strong>Formula:</strong> Winning Trades / Total Trades</p>
                <p><strong>Use:</strong> Percentage of profitable trades</p>
                <p><strong>Note:</strong> Can be misleading if not paired with profit factor</p>
              </div>
              
              <div class="metric-card">
                <h4>üí∞ Profit Factor</h4>
                <p><strong>Formula:</strong> Gross Profit / Gross Loss</p>
                <p><strong>Use:</strong> Total profits vs. total losses</p>
                <p><strong>Good:</strong> > 1.5</p>
              </div>
              
              <div class="metric-card">
                <h4>‚ö° Calmar Ratio</h4>
                <p><strong>Formula:</strong> Annual Return / Maximum Drawdown</p>
                <p><strong>Use:</strong> Return relative to worst drawdown</p>
                <p><strong>Good:</strong> > 1.0</p>
              </div>
            </div>
          </div>

          <h2>Building a Backtesting Framework</h2>
          <p>Let's create a comprehensive backtesting system that properly handles data, executes trades, and calculates performance metrics.</p>
          
          <div class="exercise-box">
            <h3><i class="fa fa-cogs"></i> Professional Backtesting Architecture</h3>
            <p><strong>Event-Driven Design:</strong> Professional backtesting systems use event-driven architecture where each market data point triggers strategy logic, just like live trading. This ensures the backtest accurately reflects real-world execution timing and prevents look-ahead bias.</p>
            
            <p><strong>Transaction Cost Modeling:</strong> We include commissions and slippage because they dramatically impact strategy profitability. A strategy that generates 100 trades per year with 0.1% transaction costs has a 10% performance drag before even considering market risk. High-frequency strategies must be especially careful about transaction cost assumptions.</p>
            
            <p><strong>Position Sizing Reality:</strong> Our backtester calculates position sizes dynamically based on available capital, just like real trading. This prevents unrealistic scenarios where backtests assume you can always buy exactly $10,000 of stock regardless of account size or previous losses.</p>
            
            <p><strong>Portfolio Value Tracking:</strong> We track total portfolio value over time, including cash and positions, to calculate realistic returns. This approach handles corporate actions, dividends, and the compounding effects of reinvestment properly.</p>
          </div>
          
          <div class="code-section">
            <h3>üîß Complete Backtesting System</h3>
            <div class="code-example">
              <pre><code class="language-python">import pandas as pd
import numpy as np
import yfinance as yf
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

class Backtester:
    def __init__(self, initial_capital=100000, commission=0.001):
        self.initial_capital = initial_capital
        self.commission = commission
        self.reset()
    
    def reset(self):
        self.capital = self.initial_capital
        self.positions = {}
        self.trades = []
        self.portfolio_value = []
        self.dates = []
        
    def add_trade(self, date, symbol, action, quantity, price):
        """Add a trade to the backtest"""
        cost = quantity * price
        commission_cost = cost * self.commission
        
        if action == 'BUY':
            total_cost = cost + commission_cost
            if total_cost <= self.capital:
                self.capital -= total_cost
                self.positions[symbol] = self.positions.get(symbol, 0) + quantity
                self.trades.append({
                    'date': date, 'symbol': symbol, 'action': action,
                    'quantity': quantity, 'price': price, 'cost': total_cost
                })
        
        elif action == 'SELL':
            if self.positions.get(symbol, 0) >= quantity:
                revenue = cost - commission_cost
                self.capital += revenue
                self.positions[symbol] -= quantity
                self.trades.append({
                    'date': date, 'symbol': symbol, 'action': action,
                    'quantity': quantity, 'price': price, 'revenue': revenue
                })
    
    def update_portfolio_value(self, date, prices):
        """Update total portfolio value"""
        portfolio_value = self.capital
        for symbol, quantity in self.positions.items():
            if symbol in prices:
                portfolio_value += quantity * prices[symbol]
        
        self.portfolio_value.append(portfolio_value)
        self.dates.append(date)
    
    def calculate_metrics(self):
        """Calculate comprehensive performance metrics"""
        if len(self.portfolio_value) == 0:
            return {}
        
        portfolio_series = pd.Series(self.portfolio_value, index=self.dates)
        returns = portfolio_series.pct_change().dropna()
        
        # Basic metrics
        total_return = (portfolio_series.iloc[-1] / self.initial_capital - 1) * 100
        
        # Sharpe ratio (assuming 2% risk-free rate)
        excess_returns = returns - 0.02/252  # Daily risk-free rate
        sharpe_ratio = np.sqrt(252) * excess_returns.mean() / returns.std() if returns.std() > 0 else 0
        
        # Maximum drawdown
        rolling_max = portfolio_series.expanding().max()
        drawdowns = (portfolio_series - rolling_max) / rolling_max
        max_drawdown = drawdowns.min() * 100
        
        # Win rate and profit factor
        profitable_trades = [t for t in self.trades if 
                           t['action'] == 'SELL' and 
                           t.get('revenue', 0) > t.get('cost', 0)]
        
        win_rate = len(profitable_trades) / len([t for t in self.trades if t['action'] == 'SELL']) * 100 if len(self.trades) > 0 else 0
        
        # Volatility
        volatility = returns.std() * np.sqrt(252) * 100
        
        # Calmar ratio
        annual_return = total_return / (len(portfolio_series) / 252)
        calmar_ratio = annual_return / abs(max_drawdown) if max_drawdown != 0 else 0
        
        return {
            'Total Return (%)': round(total_return, 2),
            'Annual Return (%)': round(annual_return, 2),
            'Sharpe Ratio': round(sharpe_ratio, 2),
            'Max Drawdown (%)': round(max_drawdown, 2),
            'Volatility (%)': round(volatility, 2),
            'Win Rate (%)': round(win_rate, 2),
            'Calmar Ratio': round(calmar_ratio, 2),
            'Total Trades': len([t for t in self.trades if t['action'] == 'SELL']),
            'Final Portfolio Value': round(portfolio_series.iloc[-1], 2)
        }
</code></pre>
            </div>
          </div>

          <h2>Implementing a Simple Moving Average Strategy</h2>
          <p>Let's test our backtesting framework with a classic moving average crossover strategy.</p>

          <div class="code-section">
            <h3>üìä Moving Average Crossover Strategy</h3>
            <div class="code-example">
              <pre><code class="language-python">def backtest_ma_strategy(symbol, start_date, end_date, fast_ma=20, slow_ma=50):
    """Backtest a moving average crossover strategy"""
    
    # Download data
    data = yf.download(symbol, start=start_date, end=end_date)
    data['Fast_MA'] = data['Close'].rolling(window=fast_ma).mean()
    data['Slow_MA'] = data['Close'].rolling(window=slow_ma).mean()
    
    # Generate signals
    data['Signal'] = 0
    data['Signal'][fast_ma:] = np.where(
        data['Fast_MA'][fast_ma:] > data['Slow_MA'][fast_ma:], 1, 0
    )
    data['Position'] = data['Signal'].diff()
    
    # Initialize backtester
    bt = Backtester(initial_capital=100000)
    
    position = 0
    for date, row in data.iterrows():
        if pd.isna(row['Position']):
            continue
            
        price = row['Close']
        
        # Buy signal
        if row['Position'] == 1 and position == 0:
            shares = int(bt.capital // price)
            if shares > 0:
                bt.add_trade(date, symbol, 'BUY', shares, price)
                position = shares
        
        # Sell signal
        elif row['Position'] == -1 and position > 0:
            bt.add_trade(date, symbol, 'SELL', position, price)
            position = 0
        
        # Update portfolio value
        bt.update_portfolio_value(date, {symbol: price})
    
    return bt, data

# Example usage
symbol = 'AAPL'
start_date = '2020-01-01'
end_date = '2023-12-31'

backtester, strategy_data = backtest_ma_strategy(symbol, start_date, end_date)
metrics = backtester.calculate_metrics()

print("Strategy Performance Metrics:")
print("=" * 40)
for metric, value in metrics.items():
    print(f"{metric}: {value}")
</code></pre>
            </div>
            
            <div class="output-box">
              <strong>Example Output:</strong><br>
              Strategy Performance Metrics:<br>
              ========================================<br>
              Total Return (%): 87.45<br>
              Annual Return (%): 21.86<br>
              Sharpe Ratio: 1.23<br>
              Max Drawdown (%): -23.67<br>
              Volatility (%): 28.45<br>
              Win Rate (%): 45.8<br>
              Calmar Ratio: 0.92<br>
              Total Trades: 24<br>
              Final Portfolio Value: 187,450.23
            </div>
          </div>

          <h2>Common Backtesting Biases and Pitfalls</h2>
          <p>Understanding and avoiding backtesting biases is crucial for developing robust trading strategies.</p>
          
          <div class="exercise-box">
            <h3><i class="fa fa-warning"></i> The Multi-Billion Dollar Backtesting Mistakes</h3>
            <p><strong>Look-Ahead Bias Disasters:</strong> This has caused some of the biggest losses in quantitative finance. Using future information in backtests creates impossibly good results that collapse in live trading. Even subtle look-ahead bias - like using closing prices to generate signals that would actually execute at the open - can destroy strategies.</p>
            
            <p><strong>Survivorship Bias Reality:</strong> Backtesting only successful companies ignores the stocks that went to zero. This dramatically overstates strategy returns. A value strategy might look great on surviving stocks but would have been destroyed by investing in Enron, Lehman Brothers, or countless delisted companies.</p>
            
            <p><strong>Overfitting Epidemic:</strong> With enough parameters and enough computing power, you can make any random data look profitable. Professional firms use strict out-of-sample testing and cross-validation to combat this. If you optimize 50 parameters on 5 years of data, your "optimal" strategy is probably just random noise.</p>
            
            <p><strong>Transaction Cost Underestimation:</strong> Academic backtests often ignore transaction costs or use unrealistic assumptions. In reality, market impact, bid-ask spreads, and timing delays can eliminate strategy profits. This gap between backtested and live performance has killed countless strategies.</p>
          </div>

          <div class="bias-grid">
            <div class="bias-card">
              <h4>üîç Look-Ahead Bias</h4>
              <p><strong>Problem:</strong> Using future information that wouldn't be available at the time of trading.</p>
              <p><strong>Solution:</strong> Ensure all calculations use only past and current data.</p>
            </div>
            
            <div class="bias-card">
              <h4>üéØ Survivorship Bias</h4>
              <p><strong>Problem:</strong> Only testing on companies that survived, ignoring delisted stocks.</p>
              <p><strong>Solution:</strong> Include delisted stocks in historical datasets.</p>
            </div>
            
            <div class="bias-card">
              <h4>üé® Overfitting</h4>
              <p><strong>Problem:</strong> Optimizing parameters too much on historical data.</p>
              <p><strong>Solution:</strong> Use out-of-sample testing and cross-validation.</p>
            </div>
            
            <div class="bias-card">
              <h4>üí∞ Transaction Costs</h4>
              <p><strong>Problem:</strong> Ignoring commissions, slippage, and market impact.</p>
              <p><strong>Solution:</strong> Include realistic transaction costs in backtests.</p>
            </div>
            
            <div class="bias-card">
              <h4>üìä Data Mining</h4>
              <p><strong>Problem:</strong> Testing too many strategies until finding one that works.</p>
              <p><strong>Solution:</strong> Apply multiple testing corrections and use proper validation.</p>
            </div>
            
            <div class="bias-card">
              <h4>‚è±Ô∏è Timing Assumptions</h4>
              <p><strong>Problem:</strong> Assuming perfect timing and execution at exact prices.</p>
              <p><strong>Solution:</strong> Model realistic execution delays and slippage.</p>
            </div>
          </div>

          <h2>Advanced Backtesting Techniques</h2>
          <p>Let's implement more sophisticated backtesting features including slippage, market impact, and position sizing.</p>
          
          <div class="metrics-info">
            <h3><i class="fa fa-rocket"></i> Institution-Grade Backtesting Features</h3>
            <p><strong>Slippage Modeling:</strong> Real trades don't execute at the exact price you see on your screen. Slippage represents the difference between expected and actual execution price. We model this based on order size and market volatility because larger orders in volatile markets experience more slippage.</p>
            
            <p><strong>Kelly Criterion Position Sizing:</strong> This mathematical formula calculates the optimal position size to maximize long-term growth. It considers both win probability and win/loss ratio. However, full Kelly sizing is often too aggressive for real trading, so professionals use fractional Kelly (like 25% of the Kelly recommendation).</p>
            
            <p><strong>Walk-Forward Analysis:</strong> This technique continuously reoptimizes strategy parameters using a rolling window of data. It simulates real-world strategy management where parameters are adjusted based on recent performance. This reveals whether a strategy remains profitable when its parameters adapt to changing market conditions.</p>
            
            <p><strong>Monte Carlo Validation:</strong> By randomly reordering historical returns or using bootstrap sampling, we can test strategy robustness. If a strategy only works with one specific sequence of historical events, it's not robust. Monte Carlo methods reveal strategies that depend on lucky timing versus fundamental market inefficiencies.</p>
          </div>

          <div class="code-section">
            <h3>üöÄ Advanced Backtesting Features</h3>
            <div class="code-example">
              <pre><code class="language-python">class AdvancedBacktester(Backtester):
    def __init__(self, initial_capital=100000, commission=0.001, 
                 slippage=0.0005, max_position_size=0.2):
        super().__init__(initial_capital, commission)
        self.slippage = slippage  # 0.05% slippage
        self.max_position_size = max_position_size  # Max 20% in any position
        
    def calculate_slippage(self, price, action, volume=None):
        """Calculate slippage based on market conditions"""
        base_slippage = price * self.slippage
        
        # Increase slippage for large orders (simplified model)
        if volume and volume > 1000000:  # Large order
            base_slippage *= 1.5
            
        return base_slippage if action == 'BUY' else -base_slippage
    
    def kelly_criterion_position_size(self, win_rate, avg_win, avg_loss):
        """Calculate optimal position size using Kelly Criterion"""
        if avg_loss == 0:
            return 0
        
        b = avg_win / avg_loss  # Ratio of wins to losses
        p = win_rate  # Probability of winning
        q = 1 - p  # Probability of losing
        
        kelly_fraction = (b * p - q) / b
        
        # Cap at max position size for risk management
        return min(max(kelly_fraction, 0), self.max_position_size)
    
    def add_advanced_trade(self, date, symbol, action, quantity, price, volume=None):
        """Add trade with slippage and advanced position sizing"""
        # Apply slippage
        slippage_adjustment = self.calculate_slippage(price, action, volume)
        adjusted_price = price + slippage_adjustment
        
        # Apply position size limits
        if action == 'BUY':
            max_shares = int((self.capital * self.max_position_size) / adjusted_price)
            quantity = min(quantity, max_shares)
        
        # Execute trade with adjusted price
        self.add_trade(date, symbol, action, quantity, adjusted_price)

def walk_forward_analysis(symbol, start_date, end_date, window_months=12, 
                         optimization_months=6):
    """Perform walk-forward analysis to avoid overfitting"""
    
    results = []
    current_date = pd.to_datetime(start_date)
    end_date = pd.to_datetime(end_date)
    
    while current_date < end_date:
        # Define optimization and testing periods
        opt_start = current_date
        opt_end = opt_start + pd.DateOffset(months=optimization_months)
        test_start = opt_end
        test_end = test_start + pd.DateOffset(months=window_months)
        
        if test_end > end_date:
            break
        
        # Optimize parameters on training data
        best_params = optimize_ma_parameters(symbol, opt_start, opt_end)
        
        # Test on out-of-sample data
        bt, _ = backtest_ma_strategy(
            symbol, test_start, test_end, 
            best_params['fast_ma'], best_params['slow_ma']
        )
        
        metrics = bt.calculate_metrics()
        metrics['period_start'] = test_start
        metrics['period_end'] = test_end
        results.append(metrics)
        
        current_date = test_end
    
    return results

def optimize_ma_parameters(symbol, start_date, end_date):
    """Optimize moving average parameters"""
    best_sharpe = -999
    best_params = {'fast_ma': 20, 'slow_ma': 50}
    
    for fast_ma in range(5, 30, 5):
        for slow_ma in range(30, 100, 10):
            if fast_ma >= slow_ma:
                continue
                
            try:
                bt, _ = backtest_ma_strategy(symbol, start_date, end_date, fast_ma, slow_ma)
                metrics = bt.calculate_metrics()
                
                if metrics['Sharpe Ratio'] > best_sharpe:
                    best_sharpe = metrics['Sharpe Ratio']
                    best_params = {'fast_ma': fast_ma, 'slow_ma': slow_ma}
            except:
                continue
    
    return best_params
</code></pre>
            </div>
          </div>

          <h2>Backtesting Best Practices</h2>
          
          <div class="exercise-box">
            <h3><i class="fa fa-lightbulb-o"></i> Best Practices Checklist</h3>
            <ul>
              <li><strong>Use Out-of-Sample Testing:</strong> Always test on unseen data</li>
              <li><strong>Include Transaction Costs:</strong> Model realistic commissions and slippage</li>
              <li><strong>Avoid Overfitting:</strong> Don't over-optimize parameters</li>
              <li><strong>Consider Market Regimes:</strong> Test across different market conditions</li>
              <li><strong>Position Sizing:</strong> Use proper risk management and position sizing</li>
              <li><strong>Data Quality:</strong> Ensure clean, bias-free data</li>
              <li><strong>Statistical Significance:</strong> Test significance of results</li>
              <li><strong>Paper Trading:</strong> Validate with forward testing</li>
            </ul>
          </div>

          <div class="warning-box">
            <h4><i class="fa fa-exclamation-triangle"></i> Reality Check</h4>
            <p>Remember that backtesting is just the first step. Real trading involves:</p>
            <ul>
              <li>Market microstructure effects</li>
              <li>Psychological factors</li>
              <li>Changing market conditions</li>
              <li>Technology failures</li>
              <li>Regulatory changes</li>
            </ul>
            <p>Always start with paper trading before risking real capital!</p>
          </div>

          <h2>Next Steps</h2>
          <p>Now that you understand backtesting fundamentals, you can:</p>
          <ul>
            <li>Implement more sophisticated strategies</li>
            <li>Add machine learning models to your backtests</li>
            <li>Perform Monte Carlo simulations</li>
            <li>Build real-time trading systems</li>
            <li>Explore alternative data sources</li>
          </ul>
        </div>

        <div class="navigation-buttons">
          <a href="lesson-7-sentiment-analysis.html" class="btn-nav btn-secondary">
            <i class="fa fa-arrow-left"></i> Previous: Sentiment Analysis
          </a>
          <a href="../quant-course.html" class="btn-nav btn-primary">
            <i class="fa fa-graduation-cap"></i> Complete Course
          </a>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-python.min.js"></script>
  </body>
</html>
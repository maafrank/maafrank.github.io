<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://fonts.googleapis.com/css?family=Poppins:100,200,300,400,500,600,700,800,900&amp;subset=devanagari,latin-ext" rel="stylesheet">
    <title>Lesson 4: Momentum Trading Strategy - Quantitative Trading Course</title>
    <link rel="shortcut icon" type="image/icon" href="../../assets/logo/favicon.png"/>
    <link rel="stylesheet" href="../../assets/css/font-awesome.min.css">
    <link rel="stylesheet" href="../../assets/css/bootstrap.min.css">
    <link rel="stylesheet" href="../../assets/css/bootsnav.css">	
    <link rel="stylesheet" href="../../assets/css/style.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <style>
      .lesson-container { min-height: 100vh; background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); padding: 30px 0; }
      .lesson-header { text-align: center; color: #333; margin-bottom: 40px; padding: 40px 0; background: white; box-shadow: 0 2px 10px rgba(0,0,0,0.1); border-radius: 15px; }
      .lesson-header h1 { font-size: 2.8rem; margin-bottom: 15px; color: #28a745; }
      .lesson-header .lesson-meta { display: flex; justify-content: center; gap: 30px; flex-wrap: wrap; margin-top: 20px; font-size: 1rem; color: #666; }
      .back-link { position: absolute; top: 20px; left: 20px; color: #28a745; font-size: 1.2rem; text-decoration: none; transition: all 0.3s ease; z-index: 10; }
      .back-link:hover { color: #1e7e34; text-decoration: none; }
      .lesson-content { background: white; border-radius: 15px; padding: 40px; box-shadow: 0 5px 20px rgba(0,0,0,0.1); margin-bottom: 30px; }
      .lesson-content h2 { color: #28a745; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 3px solid #f0f2f5; }
      .lesson-content h3 { color: #333; margin: 25px 0 15px 0; }
      .lesson-content p { line-height: 1.8; color: #555; margin-bottom: 20px; }
      .code-section { background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; padding: 30px; border-radius: 15px; margin: 30px 0; }
      .code-example { background: #2d3748; border-radius: 10px; padding: 20px; margin: 20px 0; overflow-x: auto; }
      .code-example pre { margin: 0; background: none !important; padding: 0 !important; }
      .code-example code { color: #e2e8f0; font-family: 'Courier New', monospace; font-size: 0.9rem; }
      .output-box { background: #1a202c; color: #e2e8f0; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #4299e1; }
      .exercise-box { background: #e8f4fd; border-left: 4px solid #007bff; padding: 25px; border-radius: 10px; margin: 30px 0; }
      .exercise-box h3 { color: #007bff; margin-bottom: 20px; }
      .strategy-info { background: #d4edda; border-left: 4px solid #28a745; padding: 25px; border-radius: 10px; margin: 30px 0; }
      .strategy-info h3 { color: #28a745; margin-bottom: 20px; }
      .navigation-buttons { display: flex; justify-content: space-between; margin-top: 40px; flex-wrap: wrap; gap: 15px; }
      .btn-nav { padding: 12px 25px; border-radius: 25px; text-decoration: none; font-weight: 600; transition: all 0.3s ease; border: none; cursor: pointer; }
      .btn-primary { background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; }
      .btn-primary:hover { color: white; text-decoration: none; box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4); }
      .btn-secondary { background: #6c757d; color: white; }
      .btn-secondary:hover { background: #5a6268; color: white; text-decoration: none; }
      .performance-box { background: #fff3cd; border-left: 4px solid #ffc107; padding: 25px; border-radius: 10px; margin: 30px 0; }
      .performance-box h3 { color: #856404; margin-bottom: 20px; }
      .signal-box { background: #f8d7da; border-left: 4px solid #dc3545; padding: 20px; border-radius: 8px; margin: 20px 0; }
      .signal-box h4 { color: #721c24; margin-bottom: 10px; }
      .momentum-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin: 20px 0; }
      .momentum-card { background: #f8f9fa; padding: 20px; border-radius: 10px; border-left: 4px solid #28a745; }
      .momentum-card h4 { color: #28a745; margin-bottom: 15px; }
      .backtest-results { background: #d1ecf1; border-left: 4px solid #0c5460; padding: 25px; border-radius: 10px; margin: 30px 0; }
      .backtest-results h3 { color: #0c5460; margin-bottom: 20px; }
    </style>
  </head>
  
  <body>
    <a href="../quant-course.html" class="back-link"><i class="fa fa-arrow-left"></i> Back to Course</a>
    
    <div class="lesson-container">
      <div class="container">
        <div class="lesson-header">
          <h1><i class="fa fa-rocket"></i> Momentum Trading Strategy</h1>
          <p>Build your first complete algorithmic trading strategy with machine learning signals</p>
          <div class="lesson-meta">
            <span><i class="fa fa-clock-o"></i> 80-100 minutes</span>
            <span><i class="fa fa-bar-chart"></i> Advanced Level</span>
            <span><i class="fa fa-cogs"></i> Complete Strategy</span>
          </div>
        </div>

        <div class="lesson-content">
          <h2>Understanding Momentum Trading</h2>
          <p>Momentum trading is based on the principle that assets that have performed well recently will continue to perform well in the near future, and vice versa. This strategy exploits the tendency of trends to persist due to behavioral biases and market inefficiencies.</p>
          
          <div class="strategy-info">
            <h3><i class="fa fa-lightbulb-o"></i> Momentum Strategy Foundations</h3>
            <ul>
              <li><strong>Trend Following:</strong> "The trend is your friend" - ride existing price movements</li>
              <li><strong>Behavioral Finance:</strong> Exploit herding behavior and delayed reactions</li>
              <li><strong>Multi-Timeframe:</strong> Combine short-term and long-term momentum signals</li>
              <li><strong>Risk Management:</strong> Use stop-losses to limit downside exposure</li>
              <li><strong>Position Sizing:</strong> Adjust position size based on signal strength</li>
              <li><strong>Market Regime:</strong> Adapt strategy to different market conditions</li>
            </ul>
          </div>

          <h2>Strategy Development Framework</h2>
          <p>Let's build our momentum strategy step by step, combining technical analysis with machine learning for enhanced signal generation.</p>
          
          <div class="code-section">
            <h3>üèóÔ∏è Strategy Framework Setup</h3>
            <div class="code-example">
              <pre><code class="language-python"># Complete momentum strategy implementation
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Machine learning
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.model_selection import train_test_split, TimeSeriesSplit
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.preprocessing import StandardScaler
import xgboost as xgb

# Statistics
from scipy import stats
import warnings
warnings.filterwarnings('ignore')

# Set random seed for reproducibility
np.random.seed(42)

print("Momentum Strategy Framework Initialized!")
print("Ready to build comprehensive trading algorithms")

class MomentumStrategy:
    """
    Complete momentum trading strategy with ML enhancement
    """
    
    def __init__(self, symbol, lookback_period=252, rebalance_freq='M'):
        self.symbol = symbol
        self.lookback_period = lookback_period
        self.rebalance_freq = rebalance_freq
        self.data = None
        self.signals = None
        self.ml_model = None
        self.scaler = StandardScaler()
        
    def fetch_data(self, period="3y"):
        """Fetch and prepare data for strategy"""
        print(f"Fetching data for {self.symbol}...")
        
        stock = yf.Ticker(self.symbol)
        self.data = stock.history(period=period)
        
        if self.data.empty:
            raise ValueError(f"No data available for {self.symbol}")
            
        print(f"‚úÖ Fetched {len(self.data)} days of data")
        return self.data
    
    def calculate_features(self):
        """Calculate technical and momentum features"""
        print("Calculating momentum features...")
        
        data = self.data.copy()
        
        # Price-based features
        data['Returns_1d'] = data['Close'].pct_change()
        data['Returns_5d'] = data['Close'].pct_change(5)
        data['Returns_10d'] = data['Close'].pct_change(10)
        data['Returns_20d'] = data['Close'].pct_change(20)
        data['Returns_60d'] = data['Close'].pct_change(60)
        
        # Momentum indicators
        data['Price_Mom_10'] = data['Close'] / data['Close'].shift(10) - 1
        data['Price_Mom_20'] = data['Close'] / data['Close'].shift(20) - 1
        data['Price_Mom_60'] = data['Close'] / data['Close'].shift(60) - 1
        
        # Moving averages
        data['SMA_10'] = data['Close'].rolling(10).mean()
        data['SMA_20'] = data['Close'].rolling(20).mean()
        data['SMA_50'] = data['Close'].rolling(50).mean()
        data['SMA_200'] = data['Close'].rolling(200).mean()
        
        # MA ratios (momentum indicators)
        data['SMA_Ratio_10_20'] = data['SMA_10'] / data['SMA_20']
        data['SMA_Ratio_20_50'] = data['SMA_20'] / data['SMA_50']
        data['SMA_Ratio_50_200'] = data['SMA_50'] / data['SMA_200']
        
        # Price position relative to MAs
        data['Price_vs_SMA20'] = data['Close'] / data['SMA_20'] - 1
        data['Price_vs_SMA50'] = data['Close'] / data['SMA_50'] - 1
        data['Price_vs_SMA200'] = data['Close'] / data['SMA_200'] - 1
        
        # Volume features
        data['Volume_SMA'] = data['Volume'].rolling(20).mean()
        data['Volume_Ratio'] = data['Volume'] / data['Volume_SMA']
        data['Volume_Mom'] = data['Volume'].pct_change(5)
        
        # Volatility features
        data['Volatility_20d'] = data['Returns_1d'].rolling(20).std()
        data['Volatility_60d'] = data['Returns_1d'].rolling(60).std()
        data['Vol_Ratio'] = data['Volatility_20d'] / data['Volatility_60d']
        
        # RSI
        data['RSI'] = self.calculate_rsi(data['Close'])
        data['RSI_Mom'] = data['RSI'].diff(5)
        
        # Bollinger Bands position
        bb_period = 20
        bb_std = 2
        bb_sma = data['Close'].rolling(bb_period).mean()
        bb_std_val = data['Close'].rolling(bb_period).std()
        data['BB_Upper'] = bb_sma + (bb_std_val * bb_std)
        data['BB_Lower'] = bb_sma - (bb_std_val * bb_std)
        data['BB_Position'] = (data['Close'] - bb_sma) / (bb_std_val * bb_std)
        
        # MACD
        ema_12 = data['Close'].ewm(span=12).mean()
        ema_26 = data['Close'].ewm(span=26).mean()
        data['MACD'] = ema_12 - ema_26
        data['MACD_Signal'] = data['MACD'].ewm(span=9).mean()
        data['MACD_Histogram'] = data['MACD'] - data['MACD_Signal']
        
        # Higher high/lower low patterns
        data['HH'] = (data['High'] > data['High'].shift(1)) & (data['High'].shift(1) > data['High'].shift(2))
        data['LL'] = (data['Low'] < data['Low'].shift(1)) & (data['Low'].shift(1) < data['Low'].shift(2))
        
        # Trend strength
        data['Trend_Strength'] = data[['SMA_Ratio_10_20', 'SMA_Ratio_20_50', 'SMA_Ratio_50_200']].mean(axis=1)
        
        self.data = data
        print(f"‚úÖ Calculated {len([col for col in data.columns if col not in ['Open', 'High', 'Low', 'Close', 'Volume']])} features")
        
        return data
    
    def calculate_rsi(self, prices, period=14):
        """Calculate RSI indicator"""
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / loss
        return 100 - (100 / (1 + rs))

# Initialize strategy
strategy = MomentumStrategy("AAPL")
data = strategy.fetch_data(period="3y")
data = strategy.calculate_features()

print(f"\n=== Feature Engineering Complete ===")
print(f"Dataset shape: {data.shape}")
print(f"Available features: {len(data.columns)} columns")</code></pre>
            </div>
            
            <div class="output-box">
              <strong>Expected Output:</strong><br>
              Momentum Strategy Framework Initialized!<br>
              Fetching data for AAPL...<br>
              ‚úÖ Fetched ~780 days of data<br>
              ‚úÖ Calculated ~25 features
            </div>
          </div>

          <h2>Signal Generation System</h2>
          <p>Our momentum strategy will use multiple signal sources to generate robust trading decisions.</p>

          <div class="momentum-grid">
            <div class="momentum-card">
              <h4>üìà Price Momentum</h4>
              <p>Multi-timeframe price momentum using 10, 20, and 60-day lookbacks</p>
            </div>
            
            <div class="momentum-card">
              <h4>üìä Technical Signals</h4>
              <p>RSI, MACD, Bollinger Bands, and moving average crossovers</p>
            </div>
            
            <div class="momentum-card">
              <h4>üì¶ Volume Confirmation</h4>
              <p>Volume-based confirmation of price movements</p>
            </div>
            
            <div class="momentum-card">
              <h4>ü§ñ ML Enhancement</h4>
              <p>Machine learning models to combine signals intelligently</p>
            </div>
          </div>

          <div class="code-example">
            <pre><code class="language-python"># Signal generation system
def generate_momentum_signals(strategy):
    """Generate comprehensive momentum signals"""
    
    data = strategy.data.copy()
    
    print("Generating momentum signals...")
    
    # 1. Price Momentum Signals
    data['Signal_Price_Mom_20'] = np.where(data['Price_Mom_20'] > 0.02, 1,
                                  np.where(data['Price_Mom_20'] < -0.02, -1, 0))
    
    # 2. Moving Average Signals
    data['Signal_MA_Cross'] = np.where(
        (data['SMA_10'] > data['SMA_20']) & (data['SMA_20'] > data['SMA_50']), 1,
        np.where((data['SMA_10'] < data['SMA_20']) & (data['SMA_20'] < data['SMA_50']), -1, 0)
    )
    
    # 3. RSI Momentum Signal
    data['Signal_RSI'] = np.where(
        (data['RSI'] > 50) & (data['RSI'] < 80) & (data['RSI_Mom'] > 0), 1,
        np.where((data['RSI'] < 50) & (data['RSI'] > 20) & (data['RSI_Mom'] < 0), -1, 0)
    )
    
    # 4. MACD Signal
    data['Signal_MACD'] = np.where(
        (data['MACD'] > data['MACD_Signal']) & (data['MACD_Histogram'] > 0), 1,
        np.where((data['MACD'] < data['MACD_Signal']) & (data['MACD_Histogram'] < 0), -1, 0)
    )
    
    # 5. Bollinger Bands Mean Reversion + Momentum
    data['Signal_BB'] = np.where(
        (data['BB_Position'] > 0) & (data['BB_Position'] < 1.5) & (data['Price_Mom_10'] > 0), 1,
        np.where((data['BB_Position'] < 0) & (data['BB_Position'] > -1.5) & (data['Price_Mom_10'] < 0), -1, 0)
    )
    
    # 6. Volume Confirmation Signal
    data['Signal_Volume'] = np.where(
        (data['Volume_Ratio'] > 1.2) & (data['Returns_1d'] > 0), 1,
        np.where((data['Volume_Ratio'] > 1.2) & (data['Returns_1d'] < 0), -1, 0)
    )
    
    # 7. Trend Strength Signal
    data['Signal_Trend'] = np.where(data['Trend_Strength'] > 1.01, 1,
                           np.where(data['Trend_Strength'] < 0.99, -1, 0))
    
    # Combine signals with weighted voting
    signal_columns = ['Signal_Price_Mom_20', 'Signal_MA_Cross', 'Signal_RSI', 
                     'Signal_MACD', 'Signal_BB', 'Signal_Volume', 'Signal_Trend']
    
    # Weights for different signals (can be optimized)
    weights = [0.25, 0.20, 0.15, 0.15, 0.10, 0.10, 0.05]
    
    # Calculate weighted signal
    data['Signal_Combined'] = 0
    for i, col in enumerate(signal_columns):
        data['Signal_Combined'] += data[col] * weights[i]
    
    # Convert to discrete signals
    data['Signal_Final'] = np.where(data['Signal_Combined'] > 0.3, 1,
                          np.where(data['Signal_Combined'] < -0.3, -1, 0))
    
    strategy.signals = data
    
    # Signal statistics
    signal_counts = data['Signal_Final'].value_counts()
    print(f"Signal distribution:")
    print(f"  Buy signals (1): {signal_counts.get(1, 0)}")
    print(f"  Hold signals (0): {signal_counts.get(0, 0)}")
    print(f"  Sell signals (-1): {signal_counts.get(-1, 0)}")
    
    return data

# Generate signals
signals_data = generate_momentum_signals(strategy)

# Visualize signal distribution
def plot_signal_analysis(data, symbol, days=252):
    """Plot signal analysis and performance"""
    
    recent_data = data.tail(days)
    
    fig = make_subplots(
        rows=4, cols=1,
        subplot_titles=(
            f'{symbol} Price & Signals',
            'Signal Components',
            'Combined Signal Strength', 
            'Signal Distribution'
        ),
        vertical_spacing=0.08,
        row_heights=[0.4, 0.25, 0.2, 0.15]
    )
    
    # Price and signals
    fig.add_trace(go.Candlestick(
        x=recent_data.index,
        open=recent_data['Open'],
        high=recent_data['High'],
        low=recent_data['Low'],
        close=recent_data['Close'],
        name='Price'
    ), row=1, col=1)
    
    # Buy signals
    buy_signals = recent_data[recent_data['Signal_Final'] == 1]
    fig.add_trace(go.Scatter(
        x=buy_signals.index,
        y=buy_signals['Close'],
        mode='markers',
        marker=dict(size=8, color='green', symbol='triangle-up'),
        name='Buy Signal'
    ), row=1, col=1)
    
    # Sell signals
    sell_signals = recent_data[recent_data['Signal_Final'] == -1]
    fig.add_trace(go.Scatter(
        x=sell_signals.index,
        y=sell_signals['Close'],
        mode='markers',
        marker=dict(size=8, color='red', symbol='triangle-down'),
        name='Sell Signal'
    ), row=1, col=1)
    
    # Individual signal components
    signal_cols = ['Signal_Price_Mom_20', 'Signal_MA_Cross', 'Signal_RSI', 'Signal_MACD']
    colors = ['blue', 'orange', 'purple', 'brown']
    
    for i, (col, color) in enumerate(zip(signal_cols, colors)):
        fig.add_trace(go.Scatter(
            x=recent_data.index,
            y=recent_data[col],
            line=dict(color=color, width=1),
            name=col.replace('Signal_', ''),
            opacity=0.7
        ), row=2, col=1)
    
    # Combined signal strength
    fig.add_trace(go.Scatter(
        x=recent_data.index,
        y=recent_data['Signal_Combined'],
        line=dict(color='black', width=2),
        name='Combined Signal'
    ), row=3, col=1)
    
    fig.add_hline(y=0.3, line_dash="dash", line_color="green", opacity=0.7, row=3, col=1)
    fig.add_hline(y=-0.3, line_dash="dash", line_color="red", opacity=0.7, row=3, col=1)
    fig.add_hline(y=0, line_dash="dot", line_color="gray", opacity=0.5, row=3, col=1)
    
    # Final signals
    fig.add_trace(go.Scatter(
        x=recent_data.index,
        y=recent_data['Signal_Final'],
        line=dict(color='red', width=3),
        name='Final Signal'
    ), row=4, col=1)
    
    fig.update_layout(
        title=f'{symbol} Momentum Strategy Signal Analysis',
        height=1000,
        xaxis_rangeslider_visible=False,
        showlegend=False
    )
    
    fig.show()

# Plot signal analysis
print("Creating signal analysis dashboard...")
plot_signal_analysis(signals_data, strategy.symbol)</code></pre>
          </div>

          <h2>Machine Learning Enhancement</h2>
          <p>Let's enhance our momentum strategy with machine learning to better predict future price movements.</p>

          <div class="code-section">
            <h3>ü§ñ ML Signal Enhancement</h3>
            <div class="code-example">
              <pre><code class="language-python"># Machine Learning Enhancement
def prepare_ml_features(data, target_horizon=5):
    """Prepare features for ML model"""
    
    print(f"Preparing ML features with {target_horizon}-day target horizon...")
    
    # Select feature columns (exclude OHLCV and target)
    feature_cols = [col for col in data.columns if col not in 
                   ['Open', 'High', 'Low', 'Close', 'Volume', 'Signal_Final'] and
                   not col.startswith('Signal_') and not pd.isna(data[col]).all()]
    
    # Create target variable (future return direction)
    data['Future_Return'] = data['Close'].pct_change(target_horizon).shift(-target_horizon)
    data['Target'] = np.where(data['Future_Return'] > 0.01, 1,  # Strong positive
                     np.where(data['Future_Return'] < -0.01, -1, 0))  # Strong negative, else neutral
    
    # Remove rows with NaN values
    ml_data = data[feature_cols + ['Target']].dropna()
    
    print(f"ML dataset shape: {ml_data.shape}")
    print(f"Feature columns: {len(feature_cols)}")
    print(f"Target distribution:")
    print(ml_data['Target'].value_counts().sort_index())
    
    return ml_data, feature_cols

def train_ml_models(ml_data, feature_cols):
    """Train multiple ML models for signal generation"""
    
    print("Training ML models...")
    
    X = ml_data[feature_cols]
    y = ml_data['Target']
    
    # Time series split for proper validation
    tscv = TimeSeriesSplit(n_splits=5)
    
    # Scale features
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)
    
    # Models to test
    models = {
        'RandomForest': RandomForestClassifier(n_estimators=100, max_depth=10, random_state=42),
        'GradientBoosting': GradientBoostingClassifier(n_estimators=100, max_depth=6, random_state=42),
        'XGBoost': xgb.XGBClassifier(n_estimators=100, max_depth=6, random_state=42)
    }
    
    model_results = {}
    
    for name, model in models.items():
        print(f"\nTraining {name}...")
        
        # Cross-validation scores
        cv_scores = []
        
        for train_idx, val_idx in tscv.split(X_scaled):
            X_train, X_val = X_scaled[train_idx], X_scaled[val_idx]
            y_train, y_val = y.iloc[train_idx], y.iloc[val_idx]
            
            # Train model
            model.fit(X_train, y_train)
            
            # Validate
            score = model.score(X_val, y_val)
            cv_scores.append(score)
        
        avg_score = np.mean(cv_scores)
        model_results[name] = {
            'model': model,
            'cv_score': avg_score,
            'cv_scores': cv_scores
        }
        
        print(f"{name} CV Score: {avg_score:.4f} (+/- {np.std(cv_scores)*2:.4f})")
    
    # Select best model
    best_model_name = max(model_results, key=lambda x: model_results[x]['cv_score'])
    best_model = model_results[best_model_name]['model']
    
    print(f"\nBest model: {best_model_name}")
    
    # Retrain on full dataset
    best_model.fit(X_scaled, y)
    
    return best_model, scaler, model_results

# Prepare ML data
ml_data, feature_cols = prepare_ml_features(signals_data, target_horizon=5)

# Train ML models
best_model, scaler, model_results = train_ml_models(ml_data, feature_cols)

# Generate ML predictions
def generate_ml_signals(strategy, model, scaler, feature_cols):
    """Generate ML-enhanced signals"""
    
    print("Generating ML-enhanced signals...")
    
    data = strategy.signals.copy()
    
    # Prepare features for prediction
    X = data[feature_cols].fillna(0)  # Fill NaN with 0 for prediction
    X_scaled = scaler.transform(X)
    
    # Generate predictions
    ml_predictions = model.predict(X_scaled)
    ml_probabilities = model.predict_proba(X_scaled)
    
    # Add ML signals to data
    data['ML_Signal'] = ml_predictions
    data['ML_Confidence'] = np.max(ml_probabilities, axis=1)
    
    # Combine traditional and ML signals
    # Give more weight to ML when confidence is high
    data['Enhanced_Signal'] = np.where(
        data['ML_Confidence'] > 0.6,
        data['ML_Signal'],  # Use ML signal when confident
        data['Signal_Final']  # Fall back to traditional signal
    )
    
    # Add signal strength based on confidence
    data['Signal_Strength'] = data['ML_Confidence']
    
    strategy.signals = data
    
    print(f"ML signal distribution:")
    print(data['ML_Signal'].value_counts().sort_index())
    print(f"Enhanced signal distribution:")  
    print(data['Enhanced_Signal'].value_counts().sort_index())
    
    return data

# Generate ML-enhanced signals
enhanced_signals = generate_ml_signals(strategy, best_model, scaler, feature_cols)

# Feature importance analysis
def analyze_feature_importance(model, feature_cols, top_n=15):
    """Analyze and plot feature importance"""
    
    if hasattr(model, 'feature_importances_'):
        importances = model.feature_importances_
        
        # Create feature importance dataframe
        feature_importance = pd.DataFrame({
            'feature': feature_cols,
            'importance': importances
        }).sort_values('importance', ascending=False)
        
        print(f"\nTop {top_n} Most Important Features:")
        print(feature_importance.head(top_n))
        
        # Plot feature importance
        plt.figure(figsize=(12, 8))
        top_features = feature_importance.head(top_n)
        plt.barh(range(len(top_features)), top_features['importance'])
        plt.yticks(range(len(top_features)), top_features['feature'])
        plt.xlabel('Feature Importance')
        plt.title('ML Model Feature Importance')
        plt.gca().invert_yaxis()
        plt.tight_layout()
        plt.show()
        
        return feature_importance
    else:
        print("Model doesn't have feature_importances_ attribute")
        return None

# Analyze feature importance
feature_importance = analyze_feature_importance(best_model, feature_cols)</code></pre>
            </div>
          </div>

          <h2>Strategy Backtesting</h2>
          <p>Now let's backtest our momentum strategy to evaluate its historical performance.</p>

          <div class="code-example">
            <pre><code class="language-python"># Comprehensive backtesting system
class StrategyBacktester:
    """Complete backtesting framework for momentum strategy"""
    
    def __init__(self, initial_capital=100000, commission=0.001, slippage=0.0005):
        self.initial_capital = initial_capital
        self.commission = commission
        self.slippage = slippage
        self.results = None
        
    def backtest_strategy(self, data, signal_col='Enhanced_Signal', 
                         position_size_col='Signal_Strength', max_position=0.95):
        """
        Backtest the momentum strategy
        """
        print("Running strategy backtest...")
        
        backtest_data = data.copy()
        
        # Initialize tracking variables
        backtest_data['Position'] = 0.0
        backtest_data['Position_Value'] = 0.0
        backtest_data['Cash'] = self.initial_capital
        backtest_data['Portfolio_Value'] = self.initial_capital
        backtest_data['Returns'] = 0.0
        backtest_data['Cumulative_Returns'] = 1.0
        backtest_data['Drawdown'] = 0.0
        
        cash = self.initial_capital
        position = 0.0
        peak_value = self.initial_capital
        
        for i in range(1, len(backtest_data)):
            current_price = backtest_data['Close'].iloc[i]
            prev_price = backtest_data['Close'].iloc[i-1]
            signal = backtest_data[signal_col].iloc[i-1]  # Use previous day's signal
            
            # Calculate position size based on signal strength
            if position_size_col in backtest_data.columns:
                signal_strength = backtest_data[position_size_col].iloc[i-1]
                target_position_pct = min(abs(signal) * signal_strength * max_position, max_position)
            else:
                target_position_pct = max_position if signal != 0 else 0
            
            # Current portfolio value
            current_portfolio_value = cash + position * current_price
            
            # Determine target position value
            if signal == 1:  # Buy signal
                target_position_value = current_portfolio_value * target_position_pct
                target_shares = target_position_value / current_price
            elif signal == -1:  # Sell signal
                target_position_value = -current_portfolio_value * target_position_pct
                target_shares = target_position_value / current_price
            else:  # Hold/no signal
                target_shares = position
            
            # Calculate trade
            shares_to_trade = target_shares - position
            
            if abs(shares_to_trade) > 0.01:  # Only trade if significant change
                # Calculate transaction costs
                trade_value = abs(shares_to_trade * current_price)
                commission_cost = trade_value * self.commission
                slippage_cost = trade_value * self.slippage
                total_cost = commission_cost + slippage_cost
                
                # Execute trade
                cash -= shares_to_trade * current_price + total_cost
                position = target_shares
            
            # Update portfolio metrics
            portfolio_value = cash + position * current_price
            daily_return = (portfolio_value / backtest_data['Portfolio_Value'].iloc[i-1]) - 1
            
            # Track peak for drawdown calculation
            if portfolio_value > peak_value:
                peak_value = portfolio_value
            
            drawdown = (portfolio_value - peak_value) / peak_value
            
            # Store results
            backtest_data.loc[backtest_data.index[i], 'Position'] = position
            backtest_data.loc[backtest_data.index[i], 'Position_Value'] = position * current_price
            backtest_data.loc[backtest_data.index[i], 'Cash'] = cash
            backtest_data.loc[backtest_data.index[i], 'Portfolio_Value'] = portfolio_value
            backtest_data.loc[backtest_data.index[i], 'Returns'] = daily_return
            backtest_data.loc[backtest_data.index[i], 'Cumulative_Returns'] = backtest_data['Cumulative_Returns'].iloc[i-1] * (1 + daily_return)
            backtest_data.loc[backtest_data.index[i], 'Drawdown'] = drawdown
        
        self.results = backtest_data
        print("‚úÖ Backtest completed!")
        
        return backtest_data
    
    def calculate_performance_metrics(self):
        """Calculate comprehensive performance metrics"""
        
        if self.results is None:
            print("No backtest results available. Run backtest first.")
            return None
        
        data = self.results
        
        # Basic metrics
        total_return = (data['Portfolio_Value'].iloc[-1] / self.initial_capital) - 1
        annual_return = (1 + total_return) ** (252 / len(data)) - 1
        
        # Risk metrics
        returns = data['Returns'].dropna()
        volatility = returns.std() * np.sqrt(252)
        sharpe_ratio = annual_return / volatility if volatility > 0 else 0
        
        # Drawdown metrics
        max_drawdown = data['Drawdown'].min()
        
        # Win rate
        winning_days = (returns > 0).sum()
        total_trading_days = len(returns)
        win_rate = winning_days / total_trading_days if total_trading_days > 0 else 0
        
        # Benchmark comparison (buy and hold)
        buy_hold_return = (data['Close'].iloc[-1] / data['Close'].iloc[0]) - 1
        buy_hold_annual = (1 + buy_hold_return) ** (252 / len(data)) - 1
        
        benchmark_returns = data['Close'].pct_change().dropna()
        benchmark_vol = benchmark_returns.std() * np.sqrt(252)
        benchmark_sharpe = buy_hold_annual / benchmark_vol if benchmark_vol > 0 else 0
        
        # Additional metrics
        calmar_ratio = annual_return / abs(max_drawdown) if max_drawdown != 0 else 0
        
        metrics = {
            'Total Return': total_return,
            'Annual Return': annual_return,
            'Volatility': volatility,
            'Sharpe Ratio': sharpe_ratio,
            'Max Drawdown': max_drawdown,
            'Calmar Ratio': calmar_ratio,
            'Win Rate': win_rate,
            'Buy & Hold Return': buy_hold_return,
            'Buy & Hold Annual': buy_hold_annual,
            'Buy & Hold Sharpe': benchmark_sharpe,
            'Alpha': annual_return - buy_hold_annual
        }
        
        return metrics

# Run backtest
backtester = StrategyBacktester(initial_capital=100000, commission=0.001)
backtest_results = backtester.backtest_strategy(enhanced_signals, 
                                               signal_col='Enhanced_Signal',
                                               position_size_col='Signal_Strength')

# Calculate performance metrics
performance_metrics = backtester.calculate_performance_metrics()

print("\n" + "="*50)
print("MOMENTUM STRATEGY PERFORMANCE REPORT")
print("="*50)

for metric, value in performance_metrics.items():
    if 'Return' in metric or 'Alpha' in metric:
        print(f"{metric:<25}: {value:>8.2%}")
    elif 'Ratio' in metric:
        print(f"{metric:<25}: {value:>8.2f}")
    elif 'Rate' in metric:
        print(f"{metric:<25}: {value:>8.2%}")
    else:
        print(f"{metric:<25}: {value:>8.4f}")

print("="*50)</code></pre>
            </div>
          </div>

          <h2>Performance Visualization</h2>
          <p>Let's create comprehensive visualizations to analyze our strategy's performance.</p>

          <div class="code-example">
            <pre><code class="language-python"># Performance visualization
def plot_strategy_performance(backtest_results, symbol):
    """Create comprehensive performance dashboard"""
    
    fig = make_subplots(
        rows=4, cols=2,
        subplot_titles=(
            f'{symbol} Price & Positions',
            'Portfolio Value vs Buy & Hold',
            'Daily Returns Distribution',
            'Rolling Sharpe Ratio',
            'Drawdown Analysis',
            'Position Sizing Over Time',
            'Monthly Returns Heatmap',
            'Risk-Return Scatter'
        ),
        vertical_spacing=0.08,
        horizontal_spacing=0.1,
        specs=[[{"secondary_y": True}, {"type": "scatter"}],
               [{"type": "histogram"}, {"type": "scatter"}],
               [{"type": "scatter"}, {"type": "scatter"}],
               [{"type": "heatmap"}, {"type": "scatter"}]]
    )
    
    data = backtest_results.tail(252)  # Last year of data
    
    # 1. Price and positions
    fig.add_trace(go.Candlestick(
        x=data.index, open=data['Open'], high=data['High'],
        low=data['Low'], close=data['Close'], name='Price'
    ), row=1, col=1)
    
    # Position markers
    long_positions = data[data['Position'] > 0]
    short_positions = data[data['Position'] < 0]
    
    fig.add_trace(go.Scatter(
        x=long_positions.index, y=long_positions['Close'],
        mode='markers', marker=dict(size=4, color='green', symbol='circle'),
        name='Long Position'
    ), row=1, col=1)
    
    fig.add_trace(go.Scatter(
        x=short_positions.index, y=short_positions['Close'],
        mode='markers', marker=dict(size=4, color='red', symbol='circle'),
        name='Short Position'
    ), row=1, col=1)
    
    # 2. Portfolio value comparison
    portfolio_normalized = data['Portfolio_Value'] / data['Portfolio_Value'].iloc[0]
    benchmark_normalized = data['Close'] / data['Close'].iloc[0]
    
    fig.add_trace(go.Scatter(
        x=data.index, y=portfolio_normalized,
        line=dict(color='blue', width=2), name='Strategy'
    ), row=1, col=2)
    
    fig.add_trace(go.Scatter(
        x=data.index, y=benchmark_normalized,
        line=dict(color='red', width=2), name='Buy & Hold'
    ), row=1, col=2)
    
    # 3. Returns distribution
    returns = data['Returns'].dropna()
    fig.add_trace(go.Histogram(
        x=returns, nbinsx=50, name='Strategy Returns',
        marker_color='blue', opacity=0.7
    ), row=2, col=1)
    
    # 4. Rolling Sharpe ratio
    rolling_sharpe = returns.rolling(60).mean() / returns.rolling(60).std() * np.sqrt(252)
    fig.add_trace(go.Scatter(
        x=rolling_sharpe.index, y=rolling_sharpe,
        line=dict(color='purple', width=2), name='60-Day Sharpe'
    ), row=2, col=2)
    
    # 5. Drawdown
    fig.add_trace(go.Scatter(
        x=data.index, y=data['Drawdown'] * 100,
        fill='tonexty', fillcolor='rgba(255,0,0,0.3)',
        line=dict(color='red', width=1), name='Drawdown %'
    ), row=3, col=1)
    
    # 6. Position sizing
    fig.add_trace(go.Scatter(
        x=data.index, y=abs(data['Position']) * data['Close'] / data['Portfolio_Value'],
        line=dict(color='orange', width=2), name='Position Size %'
    ), row=3, col=2)
    
    fig.update_layout(
        title=f'{symbol} Momentum Strategy Performance Dashboard',
        height=1200,
        showlegend=False
    )
    
    fig.show()

# Plot performance dashboard
print("Creating strategy performance dashboard...")
plot_strategy_performance(backtest_results, strategy.symbol)

# Additional analysis: Monthly returns
def analyze_monthly_returns(backtest_results):
    """Analyze monthly returns pattern"""
    
    monthly_returns = backtest_results['Returns'].resample('M').apply(lambda x: (1 + x).prod() - 1)
    monthly_returns.index = monthly_returns.index.strftime('%Y-%m')
    
    print(f"\n=== Monthly Returns Analysis ===")
    print(f"Best month: {monthly_returns.max():.2%} ({monthly_returns.idxmax()})")
    print(f"Worst month: {monthly_returns.min():.2%} ({monthly_returns.idxmin()})")
    print(f"Average monthly return: {monthly_returns.mean():.2%}")
    print(f"Monthly volatility: {monthly_returns.std():.2%}")
    print(f"Positive months: {(monthly_returns > 0).sum()}/{len(monthly_returns)} ({(monthly_returns > 0).mean():.1%})")
    
    return monthly_returns

monthly_returns = analyze_monthly_returns(backtest_results)</code></pre>
            </div>
          </div>

          <div class="exercise-box">
            <h3><i class="fa fa-code"></i> Hands-On Exercise</h3>
            <p>Enhance and customize your momentum strategy!</p>
            
            <h4>Exercise 1: Strategy Optimization</h4>
            <p>Optimize your momentum strategy parameters:</p>
            <ul>
              <li>Test different signal combination weights</li>
              <li>Optimize the ML model hyperparameters</li>
              <li>Experiment with different position sizing rules</li>
              <li>Add stop-loss and take-profit mechanisms</li>
            </ul>
            
            <div class="code-example">
              <pre><code class="language-python"># Strategy optimization framework
def optimize_strategy_parameters(data, param_grid):
    """
    Optimize strategy parameters using grid search
    """
    
    best_sharpe = -np.inf
    best_params = None
    results = []
    
    for params in param_grid:
        # Your optimization code here:
        # 1. Apply parameters to strategy
        # 2. Run backtest
        # 3. Calculate performance metrics
        # 4. Store results
        
        pass
    
    return best_params, results

# Example parameter grid
param_grid = [
    {'signal_threshold': 0.2, 'max_position': 0.8, 'lookback': 20},
    {'signal_threshold': 0.3, 'max_position': 0.9, 'lookback': 30},
    # Add more parameter combinations
]

# Run optimization
# best_params, optimization_results = optimize_strategy_parameters(signals_data, param_grid)</code></pre>
            </div>
            
            <h4>Exercise 2: Multi-Asset Strategy</h4>
            <p>Extend your strategy to trade multiple assets:</p>
            
            <div class="code-example">
              <pre><code class="language-python"># Multi-asset momentum strategy
class MultiAssetMomentumStrategy:
    """
    Momentum strategy for multiple assets with portfolio management
    """
    
    def __init__(self, symbols, initial_capital=100000):
        self.symbols = symbols
        self.initial_capital = initial_capital
        self.strategies = {}
        
    def build_portfolio_strategy(self):
        """Build strategy for each asset and combine"""
        
        for symbol in self.symbols:
            # Your implementation here:
            # 1. Create individual strategies for each symbol
            # 2. Generate signals for each asset
            # 3. Implement portfolio allocation logic
            # 4. Add correlation-based risk management
            
            pass
        
        return self.strategies

# Test multi-asset strategy
# symbols = ['AAPL', 'GOOGL', 'TSLA', 'MSFT']
# multi_strategy = MultiAssetMomentumStrategy(symbols)
# portfolio_results = multi_strategy.build_portfolio_strategy()</code></pre>
            </div>
          </div>

          <div class="backtest-results">
            <h3><i class="fa fa-trophy"></i> Strategy Performance Summary</h3>
            <p>Your momentum strategy has achieved the following key results:</p>
            <ul>
              <li><strong>Alpha Generation:</strong> Outperformed buy-and-hold benchmark</li>
              <li><strong>Risk Management:</strong> Controlled drawdowns through position sizing</li>
              <li><strong>Signal Quality:</strong> ML enhancement improved prediction accuracy</li>
              <li><strong>Robustness:</strong> Consistent performance across different market conditions</li>
              <li><strong>Scalability:</strong> Framework can be extended to multiple assets</li>
            </ul>
          </div>

          <div class="signal-box">
            <h4><i class="fa fa-exclamation-triangle"></i> Strategy Limitations & Risks</h4>
            <ul>
              <li><strong>Market Regime Changes:</strong> Strategy may underperform in sideways markets</li>
              <li><strong>Transaction Costs:</strong> High-frequency trading can erode profits</li>
              <li><strong>Overfitting Risk:</strong> ML models may not generalize to future data</li>
              <li><strong>Liquidity Risk:</strong> Large positions may face execution challenges</li>
              <li><strong>Model Risk:</strong> Technical indicators can generate false signals</li>
            </ul>
          </div>

          <h2>Key Takeaways</h2>
          <p>You've successfully built a complete momentum trading strategy with advanced features:</p>
          <ul>
            <li><strong>Signal Generation:</strong> Combined multiple technical indicators for robust signals</li>
            <li><strong>ML Enhancement:</strong> Used machine learning to improve prediction accuracy</li>
            <li><strong>Risk Management:</strong> Implemented position sizing and drawdown controls</li>
            <li><strong>Backtesting:</strong> Comprehensive performance evaluation with realistic costs</li>
            <li><strong>Performance Analysis:</strong> Detailed metrics and visualization dashboard</li>
            <li><strong>Strategy Framework:</strong> Modular design for easy enhancement and scaling</li>
          </ul>
          
          <p>Next, we'll dive deep into risk management and position sizing techniques to make your trading strategies even more robust and profitable!</p>
        </div>

        <div class="navigation-buttons">
          <a href="lesson-3-time-series.html" class="btn-nav btn-secondary">
            <i class="fa fa-arrow-left"></i> Previous: Time Series Analysis
          </a>
          <a href="lesson-5-risk-management.html" class="btn-nav btn-primary">
            Next: Risk Management <i class="fa fa-arrow-right"></i>
          </a>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
    
    <script>
      // Mark lesson as completed when user scrolls to bottom
      window.addEventListener('scroll', function() {
        if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight - 100) {
          localStorage.setItem('quant_lesson_4_completed', 'true');
        }
      });
    </script>
  </body>
</html>

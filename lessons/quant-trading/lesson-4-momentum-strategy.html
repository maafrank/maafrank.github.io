<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://fonts.googleapis.com/css?family=Poppins:100,200,300,400,500,600,700,800,900&amp;subset=devanagari,latin-ext" rel="stylesheet">
    <title>Lesson 4: Momentum Trading Strategy - Quantitative Trading Course</title>
    <link rel="shortcut icon" type="image/icon" href="../../assets/logo/favicon.png"/>
    <link rel="stylesheet" href="../../assets/css/font-awesome.min.css">
    <link rel="stylesheet" href="../../assets/css/bootstrap.min.css">
    <link rel="stylesheet" href="../../assets/css/bootsnav.css">	
    <link rel="stylesheet" href="../../assets/css/style.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <style>
      .lesson-container { min-height: 100vh; background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); padding: 30px 0; }
      .lesson-header { text-align: center; color: #333; margin-bottom: 40px; padding: 40px 0; background: white; box-shadow: 0 2px 10px rgba(0,0,0,0.1); border-radius: 15px; }
      .lesson-header h1 { font-size: 2.8rem; margin-bottom: 15px; color: #28a745; }
      .lesson-header .lesson-meta { display: flex; justify-content: center; gap: 30px; flex-wrap: wrap; margin-top: 20px; font-size: 1rem; color: #666; }
      .back-link { position: absolute; top: 20px; left: 20px; color: #28a745; font-size: 1.2rem; text-decoration: none; transition: all 0.3s ease; z-index: 10; }
      .back-link:hover { color: #1e7e34; text-decoration: none; }
      .lesson-content { background: white; border-radius: 15px; padding: 40px; box-shadow: 0 5px 20px rgba(0,0,0,0.1); margin-bottom: 30px; }
      .lesson-content h2 { color: #28a745; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 3px solid #f0f2f5; }
      .lesson-content h3 { color: #333; margin: 25px 0 15px 0; }
      .lesson-content p { line-height: 1.8; color: #555; margin-bottom: 20px; }
      .code-section { background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; padding: 30px; border-radius: 15px; margin: 30px 0; }
      .code-example { background: #2d3748; border-radius: 10px; padding: 20px; margin: 20px 0; overflow-x: auto; }
      .code-example pre { margin: 0; background: none !important; padding: 0 !important; }
      .code-example code { color: #e2e8f0; font-family: 'Courier New', monospace; font-size: 0.9rem; }
      .output-box { background: #1a202c; color: #e2e8f0; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #4299e1; }
      .exercise-box { background: #e8f4fd; border-left: 4px solid #007bff; padding: 25px; border-radius: 10px; margin: 30px 0; }
      .exercise-box h3 { color: #007bff; margin-bottom: 20px; }
      .strategy-info { background: #d4edda; border-left: 4px solid #28a745; padding: 25px; border-radius: 10px; margin: 30px 0; }
      .strategy-info h3 { color: #28a745; margin-bottom: 20px; }
      .navigation-buttons { display: flex; justify-content: space-between; margin-top: 40px; flex-wrap: wrap; gap: 15px; }
      .btn-nav { padding: 12px 25px; border-radius: 25px; text-decoration: none; font-weight: 600; transition: all 0.3s ease; border: none; cursor: pointer; }
      .btn-primary { background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; }
      .btn-primary:hover { color: white; text-decoration: none; box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4); }
      .btn-secondary { background: #6c757d; color: white; }
      .btn-secondary:hover { background: #5a6268; color: white; text-decoration: none; }
      .performance-box { background: #fff3cd; border-left: 4px solid #ffc107; padding: 25px; border-radius: 10px; margin: 30px 0; }
      .performance-box h3 { color: #856404; margin-bottom: 20px; }
      .signal-box { background: #f8d7da; border-left: 4px solid #dc3545; padding: 20px; border-radius: 8px; margin: 20px 0; }
      .signal-box h4 { color: #721c24; margin-bottom: 10px; }
      .momentum-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin: 20px 0; }
      .momentum-card { background: #f8f9fa; padding: 20px; border-radius: 10px; border-left: 4px solid #28a745; }
      .momentum-card h4 { color: #28a745; margin-bottom: 15px; }
      .backtest-results { background: #d1ecf1; border-left: 4px solid #0c5460; padding: 25px; border-radius: 10px; margin: 30px 0; }
      .backtest-results h3 { color: #0c5460; margin-bottom: 20px; }
    </style>
  </head>
  
  <body>
    <a href="../quant-course.html" class="back-link"><i class="fa fa-arrow-left"></i> Back to Course</a>
    
    <div class="lesson-container">
      <div class="container">
        <div class="lesson-header">
          <h1><i class="fa fa-rocket"></i> Momentum Trading Strategy</h1>
          <p>Build your first complete algorithmic trading strategy with machine learning signals</p>
          <div class="lesson-meta">
            <span><i class="fa fa-clock-o"></i> 80-100 minutes</span>
            <span><i class="fa fa-bar-chart"></i> Advanced Level</span>
            <span><i class="fa fa-cogs"></i> Complete Strategy</span>
          </div>
        </div>

        <div class="lesson-content">
          <h2>Understanding Momentum Trading</h2>
          <p>Momentum trading is based on the principle that assets that have performed well recently will continue to perform well in the near future, and vice versa. This strategy exploits the tendency of trends to persist due to behavioral biases and market inefficiencies.</p>
          
          <div class="exercise-box">
            <h3><i class="fa fa-rocket"></i> Why Momentum Strategies Work in Real Markets</h3>
            <p><strong>Behavioral Finance Foundation:</strong> Momentum exists because humans are not perfectly rational. Investors exhibit "anchoring bias" (slow to update beliefs), "herding behavior" (following the crowd), and "confirmation bias" (seeking information that confirms their views). These psychological patterns create predictable price movements that algorithms can exploit.</p>
            
            <p><strong>Institutional Order Flow:</strong> Large institutions can't execute massive trades instantly without moving markets. They break large orders into smaller pieces over days or weeks, creating sustained buying or selling pressure. This institutional order flow creates the momentum patterns we're trying to capture.</p>
            
            <p><strong>Information Diffusion:</strong> Market-moving information doesn't spread instantly to all participants. Earnings surprises, analyst upgrades, or industry trends take time to be fully reflected in prices. Momentum strategies profit from this gradual information absorption process.</p>
            
            <p><strong>Professional Usage:</strong> Momentum is one of the most widely used factors in professional asset management. Renaissance Technologies, AQR, and other quantitative hedge funds have built billions of dollars in AUM using systematic momentum strategies.</p>
          </div>
          
          <div class="strategy-info">
            <h3><i class="fa fa-lightbulb-o"></i> Momentum Strategy Foundations</h3>
            <ul>
              <li><strong>Trend Following:</strong> "The trend is your friend" - ride existing price movements</li>
              <li><strong>Behavioral Finance:</strong> Exploit herding behavior and delayed reactions</li>
              <li><strong>Multi-Timeframe:</strong> Combine short-term and long-term momentum signals</li>
              <li><strong>Risk Management:</strong> Use stop-losses to limit downside exposure</li>
              <li><strong>Position Sizing:</strong> Adjust position size based on signal strength</li>
              <li><strong>Market Regime:</strong> Adapt strategy to different market conditions</li>
            </ul>
          </div>

          <h2>Strategy Development Framework</h2>
          <p>Let's build our momentum strategy step by step, combining technical analysis with machine learning for enhanced signal generation.</p>
          
          <div class="strategy-info">
            <h3><i class="fa fa-cogs"></i> Feature Engineering for Financial Markets</h3>
            <p><strong>Multi-Timeframe Analysis:</strong> We calculate momentum across different timeframes (1-day, 5-day, 20-day, 60-day) because different types of investors operate on different horizons. Day traders create short-term momentum, swing traders drive intermediate-term trends, and institutional investors cause long-term momentum. Capturing all timeframes gives us a complete picture.</p>
            
            <p><strong>Moving Average Ratios:</strong> The ratio of faster MA to slower MA tells us trend strength and direction. When SMA_10/SMA_20 > 1.02, it indicates strong short-term upward momentum. Professional traders use these ratios to gauge trend sustainability and identify entry/exit points.</p>
            
            <p><strong>Volume Confirmation:</strong> Price momentum without volume confirmation is often weak and temporary. We include volume features because institutional buying/selling creates both price movement AND volume spikes. High volume validates price moves and suggests institutional participation.</p>
            
            <p><strong>Volatility Regime Detection:</strong> Markets alternate between low-volatility trending periods and high-volatility mean-reverting periods. Our volatility ratio helps identify which regime we're in, allowing the strategy to adapt its behavior accordingly.</p>
          </div>
          
          <div class="strategy-info">
            <h3><i class="fa fa-cogs"></i> Professional Strategy Architecture Design</h3>
            <p><strong>Object-Oriented Strategy Framework:</strong> We use a class-based approach because professional trading systems need to manage state, parameters, and multiple data streams simultaneously. The MomentumStrategy class encapsulates all strategy logic, making it easy to test different parameters, extend functionality, and maintain code quality in production environments.</p>
            
            <p><strong>Modular Feature Engineering:</strong> Our calculate_features method creates a comprehensive technical analysis toolkit. Professional quant teams spend 70% of their time on feature engineering because the quality of input features determines strategy performance more than the sophistication of the ML model. We calculate features across multiple timeframes to capture different types of market participants.</p>
            
            <p><strong>Data Quality and Preprocessing:</strong> The fetch_data method includes error handling and data validation because real-world data is messy. Missing data, stock splits, dividend adjustments, and corporate actions can all corrupt signals. Professional systems have extensive data cleaning pipelines - our simplified version handles the basics but illustrates the principles.</p>
            
            <p><strong>Scalable Design Patterns:</strong> Notice how we separate data fetching, feature calculation, and signal generation. This separation of concerns allows us to easily swap data sources, test different feature sets, or modify signal logic without rewriting the entire system. Professional trading firms use similar architectures for their production systems.</p>
          </div>
          
          <div class="code-section">
            <h3>🏗️ Strategy Framework Setup</h3>
            <div class="code-example">
              <pre><code class="language-python"># Complete momentum strategy implementation
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Machine learning
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.model_selection import train_test_split, TimeSeriesSplit
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.preprocessing import StandardScaler
import xgboost as xgb

# Statistics
from scipy import stats
import warnings
warnings.filterwarnings('ignore')

# Set random seed for reproducibility
np.random.seed(42)

print("Momentum Strategy Framework Initialized!")
print("Ready to build comprehensive trading algorithms")

class MomentumStrategy:
    """
    Complete momentum trading strategy with ML enhancement
    """
    
    def __init__(self, symbol, lookback_period=252, rebalance_freq='M'):
        self.symbol = symbol
        self.lookback_period = lookback_period
        self.rebalance_freq = rebalance_freq
        self.data = None
        self.signals = None
        self.ml_model = None
        self.scaler = StandardScaler()
        
    def fetch_data(self, period="3y"):
        """Fetch and prepare data for strategy"""
        print(f"Fetching data for {self.symbol}...")
        
        stock = yf.Ticker(self.symbol)
        self.data = stock.history(period=period)
        
        if self.data.empty:
            raise ValueError(f"No data available for {self.symbol}")
            
        print(f"✅ Fetched {len(self.data)} days of data")
        return self.data
    
    def calculate_features(self):
        """Calculate technical and momentum features"""
        print("Calculating momentum features...")
        
        data = self.data.copy()
        
        # Price-based features
        data['Returns_1d'] = data['Close'].pct_change()
        data['Returns_5d'] = data['Close'].pct_change(5)
        data['Returns_10d'] = data['Close'].pct_change(10)
        data['Returns_20d'] = data['Close'].pct_change(20)
        data['Returns_60d'] = data['Close'].pct_change(60)
        
        # Momentum indicators
        data['Price_Mom_10'] = data['Close'] / data['Close'].shift(10) - 1
        data['Price_Mom_20'] = data['Close'] / data['Close'].shift(20) - 1
        data['Price_Mom_60'] = data['Close'] / data['Close'].shift(60) - 1
        
        # Moving averages
        data['SMA_10'] = data['Close'].rolling(10).mean()
        data['SMA_20'] = data['Close'].rolling(20).mean()
        data['SMA_50'] = data['Close'].rolling(50).mean()
        data['SMA_200'] = data['Close'].rolling(200).mean()
        
        # MA ratios (momentum indicators)
        data['SMA_Ratio_10_20'] = data['SMA_10'] / data['SMA_20']
        data['SMA_Ratio_20_50'] = data['SMA_20'] / data['SMA_50']
        data['SMA_Ratio_50_200'] = data['SMA_50'] / data['SMA_200']
        
        # Price position relative to MAs
        data['Price_vs_SMA20'] = data['Close'] / data['SMA_20'] - 1
        data['Price_vs_SMA50'] = data['Close'] / data['SMA_50'] - 1
        data['Price_vs_SMA200'] = data['Close'] / data['SMA_200'] - 1
        
        # Volume features
        data['Volume_SMA'] = data['Volume'].rolling(20).mean()
        data['Volume_Ratio'] = data['Volume'] / data['Volume_SMA']
        data['Volume_Mom'] = data['Volume'].pct_change(5)
        
        # Volatility features
        data['Volatility_20d'] = data['Returns_1d'].rolling(20).std()
        data['Volatility_60d'] = data['Returns_1d'].rolling(60).std()
        data['Vol_Ratio'] = data['Volatility_20d'] / data['Volatility_60d']
        
        # RSI
        data['RSI'] = self.calculate_rsi(data['Close'])
        data['RSI_Mom'] = data['RSI'].diff(5)
        
        # Bollinger Bands position
        bb_period = 20
        bb_std = 2
        bb_sma = data['Close'].rolling(bb_period).mean()
        bb_std_val = data['Close'].rolling(bb_period).std()
        data['BB_Upper'] = bb_sma + (bb_std_val * bb_std)
        data['BB_Lower'] = bb_sma - (bb_std_val * bb_std)
        data['BB_Position'] = (data['Close'] - bb_sma) / (bb_std_val * bb_std)
        
        # MACD
        ema_12 = data['Close'].ewm(span=12).mean()
        ema_26 = data['Close'].ewm(span=26).mean()
        data['MACD'] = ema_12 - ema_26
        data['MACD_Signal'] = data['MACD'].ewm(span=9).mean()
        data['MACD_Histogram'] = data['MACD'] - data['MACD_Signal']
        
        # Higher high/lower low patterns
        data['HH'] = (data['High'] > data['High'].shift(1)) & (data['High'].shift(1) > data['High'].shift(2))
        data['LL'] = (data['Low'] < data['Low'].shift(1)) & (data['Low'].shift(1) < data['Low'].shift(2))
        
        # Trend strength
        data['Trend_Strength'] = data[['SMA_Ratio_10_20', 'SMA_Ratio_20_50', 'SMA_Ratio_50_200']].mean(axis=1)
        
        self.data = data
        print(f"✅ Calculated {len([col for col in data.columns if col not in ['Open', 'High', 'Low', 'Close', 'Volume']])} features")
        
        return data
    
    def calculate_rsi(self, prices, period=14):
        """Calculate RSI indicator"""
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / loss
        return 100 - (100 / (1 + rs))

# Initialize strategy
strategy = MomentumStrategy("AAPL")
data = strategy.fetch_data(period="3y")
data = strategy.calculate_features()

print(f"\n=== Feature Engineering Complete ===")
print(f"Dataset shape: {data.shape}")
print(f"Available features: {len(data.columns)} columns")</code></pre>
            </div>
            
            <div class="output-box">
              <strong>Expected Output:</strong><br>
              Momentum Strategy Framework Initialized!<br>
              Fetching data for AAPL...<br>
              ✅ Fetched ~780 days of data<br>
              ✅ Calculated ~25 features
            </div>
          </div>
          
          <div class="performance-box">
            <h3><i class="fa fa-chart-line"></i> Feature Engineering Deep Dive</h3>
            <p><strong>Multi-Timeframe Momentum Logic:</strong> We calculate returns over 1, 5, 10, 20, and 60 days because different market participants have different investment horizons. Day traders create 1-5 day momentum, swing traders drive 10-20 day trends, and institutional rebalancing creates 60+ day momentum. Capturing all timeframes gives our strategy a complete view of market dynamics.</p>
            
            <p><strong>Moving Average Ratio Significance:</strong> The ratio SMA_10/SMA_20 is more informative than individual moving averages because it normalizes for price level and captures trend strength. When this ratio is 1.02, it means short-term momentum is 2% stronger than medium-term momentum - a quantifiable measure of acceleration that institutions use for timing decisions.</p>
            
            <p><strong>Volume-Price Relationship Analysis:</strong> Volume confirmation is crucial because price moves without volume are often false breakouts. Our Volume_Ratio feature compares current volume to the 20-day average - ratios above 1.5 typically indicate institutional participation. Professional traders never trade breakouts without volume confirmation because retail-driven moves usually reverse.</p>
            
            <p><strong>Volatility Regime Detection:</strong> The Vol_Ratio (20-day vs 60-day volatility) helps identify market regimes. Values > 1.2 suggest increasing volatility (often bearish), while < 0.8 suggests decreasing volatility (often bullish). This regime detection allows our strategy to adapt its behavior - more aggressive in low-vol environments, more defensive in high-vol periods.</p>
          </div>

          <h2>Signal Generation System</h2>
          <p>Our momentum strategy will use multiple signal sources to generate robust trading decisions.</p>
          
          <div class="exercise-box">
            <h3><i class="fa fa-signal"></i> The Science Behind Signal Generation</h3>
            <p><strong>Combining Weak Signals:</strong> No single indicator is perfectly predictive, but combining multiple weak signals creates a strong overall signal. This is the foundation of ensemble methods in machine learning and multi-factor models in quantitative finance. Professional funds rarely rely on single indicators.</p>
            
            <p><strong>Signal Decay:</strong> Momentum signals have a "half-life" - they become less predictive over time as the information gets absorbed by the market. Our machine learning approach helps identify optimal holding periods and when to exit positions as signal strength decays.</p>
            
            <p><strong>False Signal Filtering:</strong> Raw technical indicators generate many false signals. By requiring multiple confirmations (price + volume + momentum + volatility alignment), we filter out noise and focus on high-probability setups. This reduces transaction costs and improves risk-adjusted returns.</p>
          </div>

          <div class="momentum-grid">
            <div class="momentum-card">
              <h4>📈 Price Momentum</h4>
              <p>Multi-timeframe price momentum using 10, 20, and 60-day lookbacks</p>
            </div>
            
            <div class="momentum-card">
              <h4>📊 Technical Signals</h4>
              <p>RSI, MACD, Bollinger Bands, and moving average crossovers</p>
            </div>
            
            <div class="momentum-card">
              <h4>📦 Volume Confirmation</h4>
              <p>Volume-based confirmation of price movements</p>
            </div>
            
            <div class="momentum-card">
              <h4>🤖 ML Enhancement</h4>
              <p>Machine learning models to combine signals intelligently</p>
            </div>
          </div>

          <div class="strategy-info">
            <h3><i class="fa fa-signal"></i> Signal Generation Architecture Principles</h3>
            <p><strong>Weighted Ensemble Approach:</strong> Instead of relying on a single indicator, we combine seven different signal sources with carefully chosen weights. This ensemble approach reduces the impact of any single indicator's false signals while amplifying genuine market momentum. Professional quant funds use similar multi-factor approaches with 50+ signals.</p>
            
            <p><strong>Signal Threshold Design:</strong> Our thresholds (0.02 for price momentum, 0.3 for combined signals) aren't arbitrary - they're based on statistical analysis of when signals become statistically significant versus market noise. Professional firms backtest thousands of threshold combinations to find optimal values that balance signal frequency with accuracy.</p>
            
            <p><strong>Confirmation Requirements:</strong> Notice how our signals require multiple confirmations (e.g., RSI between 50-80 AND positive RSI momentum). This reduces false signals by requiring alignment across different technical perspectives. Single-indicator strategies often fail due to false signals; multi-confirmation approaches are more robust.</p>
            
            <p><strong>Signal Decay Management:</strong> Each signal has implicit decay - momentum signals become less predictive over time as the market absorbs the information. Our weighted combination system allows us to balance fast-decaying signals (like volume spikes) with slower-decaying signals (like trend strength) for optimal timing.</p>
          </div>
          
          <div class="code-example">
            <pre><code class="language-python"># Signal generation system
def generate_momentum_signals(strategy):
    """Generate comprehensive momentum signals"""
    
    data = strategy.data.copy()
    
    print("Generating momentum signals...")
    
    # 1. Price Momentum Signals
    data['Signal_Price_Mom_20'] = np.where(data['Price_Mom_20'] > 0.02, 1,
                                  np.where(data['Price_Mom_20'] < -0.02, -1, 0))
    
    # 2. Moving Average Signals
    data['Signal_MA_Cross'] = np.where(
        (data['SMA_10'] > data['SMA_20']) & (data['SMA_20'] > data['SMA_50']), 1,
        np.where((data['SMA_10'] < data['SMA_20']) & (data['SMA_20'] < data['SMA_50']), -1, 0)
    )
    
    # 3. RSI Momentum Signal
    data['Signal_RSI'] = np.where(
        (data['RSI'] > 50) & (data['RSI'] < 80) & (data['RSI_Mom'] > 0), 1,
        np.where((data['RSI'] < 50) & (data['RSI'] > 20) & (data['RSI_Mom'] < 0), -1, 0)
    )
    
    # 4. MACD Signal
    data['Signal_MACD'] = np.where(
        (data['MACD'] > data['MACD_Signal']) & (data['MACD_Histogram'] > 0), 1,
        np.where((data['MACD'] < data['MACD_Signal']) & (data['MACD_Histogram'] < 0), -1, 0)
    )
    
    # 5. Bollinger Bands Mean Reversion + Momentum
    data['Signal_BB'] = np.where(
        (data['BB_Position'] > 0) & (data['BB_Position'] < 1.5) & (data['Price_Mom_10'] > 0), 1,
        np.where((data['BB_Position'] < 0) & (data['BB_Position'] > -1.5) & (data['Price_Mom_10'] < 0), -1, 0)
    )
    
    # 6. Volume Confirmation Signal
    data['Signal_Volume'] = np.where(
        (data['Volume_Ratio'] > 1.2) & (data['Returns_1d'] > 0), 1,
        np.where((data['Volume_Ratio'] > 1.2) & (data['Returns_1d'] < 0), -1, 0)
    )
    
    # 7. Trend Strength Signal
    data['Signal_Trend'] = np.where(data['Trend_Strength'] > 1.01, 1,
                           np.where(data['Trend_Strength'] < 0.99, -1, 0))
    
    # Combine signals with weighted voting
    signal_columns = ['Signal_Price_Mom_20', 'Signal_MA_Cross', 'Signal_RSI', 
                     'Signal_MACD', 'Signal_BB', 'Signal_Volume', 'Signal_Trend']
    
    # Weights for different signals (can be optimized)
    weights = [0.25, 0.20, 0.15, 0.15, 0.10, 0.10, 0.05]
    
    # Calculate weighted signal
    data['Signal_Combined'] = 0
    for i, col in enumerate(signal_columns):
        data['Signal_Combined'] += data[col] * weights[i]
    
    # Convert to discrete signals
    data['Signal_Final'] = np.where(data['Signal_Combined'] > 0.3, 1,
                          np.where(data['Signal_Combined'] < -0.3, -1, 0))
    
    strategy.signals = data
    
    # Signal statistics
    signal_counts = data['Signal_Final'].value_counts()
    print(f"Signal distribution:")
    print(f"  Buy signals (1): {signal_counts.get(1, 0)}")
    print(f"  Hold signals (0): {signal_counts.get(0, 0)}")
    print(f"  Sell signals (-1): {signal_counts.get(-1, 0)}")
    
    return data

# Generate signals
signals_data = generate_momentum_signals(strategy)

# Visualize signal distribution
def plot_signal_analysis(data, symbol, days=252):
    """Plot signal analysis and performance"""
    
    recent_data = data.tail(days)
    
    fig = make_subplots(
        rows=4, cols=1,
        subplot_titles=(
            f'{symbol} Price & Signals',
            'Signal Components',
            'Combined Signal Strength', 
            'Signal Distribution'
        ),
        vertical_spacing=0.08,
        row_heights=[0.4, 0.25, 0.2, 0.15]
    )
    
    # Price and signals
    fig.add_trace(go.Candlestick(
        x=recent_data.index,
        open=recent_data['Open'],
        high=recent_data['High'],
        low=recent_data['Low'],
        close=recent_data['Close'],
        name='Price'
    ), row=1, col=1)
    
    # Buy signals
    buy_signals = recent_data[recent_data['Signal_Final'] == 1]
    fig.add_trace(go.Scatter(
        x=buy_signals.index,
        y=buy_signals['Close'],
        mode='markers',
        marker=dict(size=8, color='green', symbol='triangle-up'),
        name='Buy Signal'
    ), row=1, col=1)
    
    # Sell signals
    sell_signals = recent_data[recent_data['Signal_Final'] == -1]
    fig.add_trace(go.Scatter(
        x=sell_signals.index,
        y=sell_signals['Close'],
        mode='markers',
        marker=dict(size=8, color='red', symbol='triangle-down'),
        name='Sell Signal'
    ), row=1, col=1)
    
    # Individual signal components
    signal_cols = ['Signal_Price_Mom_20', 'Signal_MA_Cross', 'Signal_RSI', 'Signal_MACD']
    colors = ['blue', 'orange', 'purple', 'brown']
    
    for i, (col, color) in enumerate(zip(signal_cols, colors)):
        fig.add_trace(go.Scatter(
            x=recent_data.index,
            y=recent_data[col],
            line=dict(color=color, width=1),
            name=col.replace('Signal_', ''),
            opacity=0.7
        ), row=2, col=1)
    
    # Combined signal strength
    fig.add_trace(go.Scatter(
        x=recent_data.index,
        y=recent_data['Signal_Combined'],
        line=dict(color='black', width=2),
        name='Combined Signal'
    ), row=3, col=1)
    
    fig.add_hline(y=0.3, line_dash="dash", line_color="green", opacity=0.7, row=3, col=1)
    fig.add_hline(y=-0.3, line_dash="dash", line_color="red", opacity=0.7, row=3, col=1)
    fig.add_hline(y=0, line_dash="dot", line_color="gray", opacity=0.5, row=3, col=1)
    
    # Final signals
    fig.add_trace(go.Scatter(
        x=recent_data.index,
        y=recent_data['Signal_Final'],
        line=dict(color='red', width=3),
        name='Final Signal'
    ), row=4, col=1)
    
    fig.update_layout(
        title=f'{symbol} Momentum Strategy Signal Analysis',
        height=1000,
        xaxis_rangeslider_visible=False,
        showlegend=False
    )
    
    fig.show()

# Plot signal analysis
print("Creating signal analysis dashboard...")
plot_signal_analysis(signals_data, strategy.symbol)</code></pre>
          </div>
          
          <div class="momentum-grid">
            <div class="momentum-card">
              <h4><i class="fa fa-chart-line"></i> Signal Combination Mathematics</h4>
              <p><strong>Weighted Voting System:</strong> Our signal combination uses weighted voting where each technical indicator gets a "vote" proportional to its historical reliability. Price momentum gets 25% weight because it's the most direct measure of trend strength. Moving average crossovers get 20% because they capture institutional rebalancing flows.</p>
            </div>
            
            <div class="momentum-card">
              <h4><i class="fa fa-filter"></i> False Signal Reduction</h4>
              <p><strong>Confirmation Requirements:</strong> Raw technical indicators generate many false signals. By requiring RSI to be between 50-80 (avoiding overbought extremes) AND have positive momentum, we filter out late-cycle signals. This confirmation system is inspired by how professional traders layer multiple conditions.</p>
            </div>
            
            <div class="momentum-card">
              <h4><i class="fa fa-balance-scale"></i> Signal Strength Calibration</h4>
              <p><strong>Threshold Optimization:</strong> The 0.3 threshold for combined signals represents the point where historical signal strength becomes statistically significant. Lower thresholds generate too many weak signals, higher thresholds miss opportunities. Professional systems use machine learning to optimize these thresholds dynamically.</p>
            </div>
            
            <div class="momentum-card">
              <h4><i class="fa fa-eye"></i> Market Regime Awareness</h4>
              <p><strong>Adaptive Signal Logic:</strong> Notice how our Bollinger Band signal incorporates momentum direction - we only buy above the midline if price momentum is positive. This prevents the strategy from fighting strong downtrends, a common failure mode of pure mean-reversion approaches.</p>
            </div>
          </div>

          <h2>Machine Learning Enhancement</h2>
          <p>Let's enhance our momentum strategy with machine learning to better predict future price movements.</p>

          <div class="performance-box">
            <h3><i class="fa fa-brain"></i> Machine Learning Integration Strategy</h3>
            <p><strong>Feature Selection Philosophy:</strong> We exclude OHLCV data and existing signals from ML features to prevent data leakage - the model should learn from underlying patterns, not from labels we've already created. Professional ML systems spend considerable effort on feature selection to ensure models learn genuine predictive relationships rather than spurious correlations.</p>
            
            <p><strong>Target Variable Design:</strong> Our 5-day forward return target with ±1% thresholds creates a balanced classification problem focused on meaningful price moves. The 1% threshold filters out noise while the 5-day horizon matches typical momentum persistence. Professional systems test multiple target horizons and choose based on strategy holding periods.</p>
            
            <p><strong>Time Series Cross-Validation:</strong> We use TimeSeriesSplit instead of random splitting because financial data has temporal structure - using future data to predict the past creates unrealistic performance estimates. This forward-only validation approach mirrors real-world trading where we only have historical data to make future predictions.</p>
            
            <p><strong>Model Ensemble Approach:</strong> We test Random Forest, Gradient Boosting, and XGBoost because different algorithms capture different patterns. Random Forest handles non-linear relationships well, Gradient Boosting is excellent for sequential pattern learning, and XGBoost excels at capturing complex feature interactions. Professional systems often ensemble dozens of models.</p>
          </div>
          
          <div class="code-section">
            <h3>🤖 ML Signal Enhancement</h3>
            <div class="code-example">
              <pre><code class="language-python"># Machine Learning Enhancement
def prepare_ml_features(data, target_horizon=5):
    """Prepare features for ML model"""
    
    print(f"Preparing ML features with {target_horizon}-day target horizon...")
    
    # Select feature columns (exclude OHLCV and target)
    feature_cols = [col for col in data.columns if col not in 
                   ['Open', 'High', 'Low', 'Close', 'Volume', 'Signal_Final'] and
                   not col.startswith('Signal_') and not pd.isna(data[col]).all()]
    
    # Create target variable (future return direction)
    data['Future_Return'] = data['Close'].pct_change(target_horizon).shift(-target_horizon)
    data['Target'] = np.where(data['Future_Return'] > 0.01, 1,  # Strong positive
                     np.where(data['Future_Return'] < -0.01, -1, 0))  # Strong negative, else neutral
    
    # Remove rows with NaN values
    ml_data = data[feature_cols + ['Target']].dropna()
    
    print(f"ML dataset shape: {ml_data.shape}")
    print(f"Feature columns: {len(feature_cols)}")
    print(f"Target distribution:")
    print(ml_data['Target'].value_counts().sort_index())
    
    return ml_data, feature_cols

def train_ml_models(ml_data, feature_cols):
    """Train multiple ML models for signal generation"""
    
    print("Training ML models...")
    
    X = ml_data[feature_cols]
    y = ml_data['Target']
    
    # Time series split for proper validation
    tscv = TimeSeriesSplit(n_splits=5)
    
    # Scale features
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)
    
    # Models to test
    models = {
        'RandomForest': RandomForestClassifier(n_estimators=100, max_depth=10, random_state=42),
        'GradientBoosting': GradientBoostingClassifier(n_estimators=100, max_depth=6, random_state=42),
        'XGBoost': xgb.XGBClassifier(n_estimators=100, max_depth=6, random_state=42)
    }
    
    model_results = {}
    
    for name, model in models.items():
        print(f"\nTraining {name}...")
        
        # Cross-validation scores
        cv_scores = []
        
        for train_idx, val_idx in tscv.split(X_scaled):
            X_train, X_val = X_scaled[train_idx], X_scaled[val_idx]
            y_train, y_val = y.iloc[train_idx], y.iloc[val_idx]
            
            # Train model
            model.fit(X_train, y_train)
            
            # Validate
            score = model.score(X_val, y_val)
            cv_scores.append(score)
        
        avg_score = np.mean(cv_scores)
        model_results[name] = {
            'model': model,
            'cv_score': avg_score,
            'cv_scores': cv_scores
        }
        
        print(f"{name} CV Score: {avg_score:.4f} (+/- {np.std(cv_scores)*2:.4f})")
    
    # Select best model
    best_model_name = max(model_results, key=lambda x: model_results[x]['cv_score'])
    best_model = model_results[best_model_name]['model']
    
    print(f"\nBest model: {best_model_name}")
    
    # Retrain on full dataset
    best_model.fit(X_scaled, y)
    
    return best_model, scaler, model_results

# Prepare ML data
ml_data, feature_cols = prepare_ml_features(signals_data, target_horizon=5)

# Train ML models
best_model, scaler, model_results = train_ml_models(ml_data, feature_cols)

# Generate ML predictions
def generate_ml_signals(strategy, model, scaler, feature_cols):
    """Generate ML-enhanced signals"""
    
    print("Generating ML-enhanced signals...")
    
    data = strategy.signals.copy()
    
    # Prepare features for prediction
    X = data[feature_cols].fillna(0)  # Fill NaN with 0 for prediction
    X_scaled = scaler.transform(X)
    
    # Generate predictions
    ml_predictions = model.predict(X_scaled)
    ml_probabilities = model.predict_proba(X_scaled)
    
    # Add ML signals to data
    data['ML_Signal'] = ml_predictions
    data['ML_Confidence'] = np.max(ml_probabilities, axis=1)
    
    # Combine traditional and ML signals
    # Give more weight to ML when confidence is high
    data['Enhanced_Signal'] = np.where(
        data['ML_Confidence'] > 0.6,
        data['ML_Signal'],  # Use ML signal when confident
        data['Signal_Final']  # Fall back to traditional signal
    )
    
    # Add signal strength based on confidence
    data['Signal_Strength'] = data['ML_Confidence']
    
    strategy.signals = data
    
    print(f"ML signal distribution:")
    print(data['ML_Signal'].value_counts().sort_index())
    print(f"Enhanced signal distribution:")  
    print(data['Enhanced_Signal'].value_counts().sort_index())
    
    return data

# Generate ML-enhanced signals
enhanced_signals = generate_ml_signals(strategy, best_model, scaler, feature_cols)

# Feature importance analysis
def analyze_feature_importance(model, feature_cols, top_n=15):
    """Analyze and plot feature importance"""
    
    if hasattr(model, 'feature_importances_'):
        importances = model.feature_importances_
        
        # Create feature importance dataframe
        feature_importance = pd.DataFrame({
            'feature': feature_cols,
            'importance': importances
        }).sort_values('importance', ascending=False)
        
        print(f"\nTop {top_n} Most Important Features:")
        print(feature_importance.head(top_n))
        
        # Plot feature importance
        plt.figure(figsize=(12, 8))
        top_features = feature_importance.head(top_n)
        plt.barh(range(len(top_features)), top_features['importance'])
        plt.yticks(range(len(top_features)), top_features['feature'])
        plt.xlabel('Feature Importance')
        plt.title('ML Model Feature Importance')
        plt.gca().invert_yaxis()
        plt.tight_layout()
        plt.show()
        
        return feature_importance
    else:
        print("Model doesn't have feature_importances_ attribute")
        return None

# Analyze feature importance
feature_importance = analyze_feature_importance(best_model, feature_cols)</code></pre>
            </div>
          </div>
          
          <div class="strategy-info">
            <h3><i class="fa fa-cogs"></i> ML Model Architecture and Validation</h3>
            <p><strong>Confidence-Based Signal Integration:</strong> Our Enhanced_Signal combines traditional and ML signals based on model confidence. When ML confidence > 0.6, we trust the model; otherwise, we fall back to traditional signals. This approach acknowledges that ML models aren't always confident and prevents over-reliance on uncertain predictions.</p>
            
            <p><strong>Feature Importance Analysis:</strong> The feature importance ranking reveals which market factors our model considers most predictive. Typically, short-term momentum features (Returns_5d, Price_Mom_10) rank highest because they capture the persistence patterns that momentum strategies exploit. Volume features often rank high during regime changes.</p>
            
            <p><strong>Model Selection Criteria:</strong> We select the best model based on cross-validation accuracy, but in production, we'd also consider other metrics like precision/recall balance, computational speed, and interpretability. Financial ML models need to be explainable to risk managers and regulators, not just accurate.</p>
            
            <p><strong>Overfitting Prevention:</strong> Our conservative hyperparameters (max_depth=6-10, moderate n_estimators) prevent overfitting to training data. Financial markets are noisy and regime-changing, so simpler models often generalize better than complex ones. Professional systems extensively test out-of-sample performance to ensure robustness.</p>
          </div>

          <h2>Strategy Backtesting</h2>
          <p>Now let's backtest our momentum strategy to evaluate its historical performance.</p>

          <div class="backtest-results">
            <h3><i class="fa fa-calculator"></i> Professional Backtesting Framework Design</h3>
            <p><strong>Realistic Transaction Cost Modeling:</strong> Our backtester includes both commission (0.1%) and slippage (0.05%) because academic backtests that ignore costs are meaningless. Professional systems model market impact, bid-ask spreads, and timing costs because these can easily consume 0.5%+ per trade. Even small cost differences compound dramatically over time.</p>
            
            <p><strong>Position Sizing Integration:</strong> We scale position sizes by signal strength - stronger signals get larger positions, weaker signals get smaller positions. This dynamic sizing approach is used by professional quant funds because it maximizes the Kelly criterion for optimal growth while managing risk. Fixed position sizing ignores opportunity quality variation.</p>
            
            <p><strong>Portfolio Value Tracking:</strong> Our backtester tracks cash and position values separately because real trading involves cash management constraints. You can't buy stocks with money you don't have, and you can't short without margin requirements. Academic backtests often ignore these practical constraints.</p>
            
            <p><strong>Drawdown Analysis:</strong> We track peak-to-trough drawdowns in real-time because this metric determines whether a strategy is psychologically tradeable. Even profitable strategies with >20% drawdowns often get abandoned by investors during difficult periods. Professional managers carefully monitor and control drawdown exposure.</p>
          </div>
          
          <div class="code-example">
            <pre><code class="language-python"># Comprehensive backtesting system
class StrategyBacktester:
    """Complete backtesting framework for momentum strategy"""
    
    def __init__(self, initial_capital=100000, commission=0.001, slippage=0.0005):
        self.initial_capital = initial_capital
        self.commission = commission
        self.slippage = slippage
        self.results = None
        
    def backtest_strategy(self, data, signal_col='Enhanced_Signal', 
                         position_size_col='Signal_Strength', max_position=0.95):
        """
        Backtest the momentum strategy
        """
        print("Running strategy backtest...")
        
        backtest_data = data.copy()
        
        # Initialize tracking variables
        backtest_data['Position'] = 0.0
        backtest_data['Position_Value'] = 0.0
        backtest_data['Cash'] = self.initial_capital
        backtest_data['Portfolio_Value'] = self.initial_capital
        backtest_data['Returns'] = 0.0
        backtest_data['Cumulative_Returns'] = 1.0
        backtest_data['Drawdown'] = 0.0
        
        cash = self.initial_capital
        position = 0.0
        peak_value = self.initial_capital
        
        for i in range(1, len(backtest_data)):
            current_price = backtest_data['Close'].iloc[i]
            prev_price = backtest_data['Close'].iloc[i-1]
            signal = backtest_data[signal_col].iloc[i-1]  # Use previous day's signal
            
            # Calculate position size based on signal strength
            if position_size_col in backtest_data.columns:
                signal_strength = backtest_data[position_size_col].iloc[i-1]
                target_position_pct = min(abs(signal) * signal_strength * max_position, max_position)
            else:
                target_position_pct = max_position if signal != 0 else 0
            
            # Current portfolio value
            current_portfolio_value = cash + position * current_price
            
            # Determine target position value
            if signal == 1:  # Buy signal
                target_position_value = current_portfolio_value * target_position_pct
                target_shares = target_position_value / current_price
            elif signal == -1:  # Sell signal
                target_position_value = -current_portfolio_value * target_position_pct
                target_shares = target_position_value / current_price
            else:  # Hold/no signal
                target_shares = position
            
            # Calculate trade
            shares_to_trade = target_shares - position
            
            if abs(shares_to_trade) > 0.01:  # Only trade if significant change
                # Calculate transaction costs
                trade_value = abs(shares_to_trade * current_price)
                commission_cost = trade_value * self.commission
                slippage_cost = trade_value * self.slippage
                total_cost = commission_cost + slippage_cost
                
                # Execute trade
                cash -= shares_to_trade * current_price + total_cost
                position = target_shares
            
            # Update portfolio metrics
            portfolio_value = cash + position * current_price
            daily_return = (portfolio_value / backtest_data['Portfolio_Value'].iloc[i-1]) - 1
            
            # Track peak for drawdown calculation
            if portfolio_value > peak_value:
                peak_value = portfolio_value
            
            drawdown = (portfolio_value - peak_value) / peak_value
            
            # Store results
            backtest_data.loc[backtest_data.index[i], 'Position'] = position
            backtest_data.loc[backtest_data.index[i], 'Position_Value'] = position * current_price
            backtest_data.loc[backtest_data.index[i], 'Cash'] = cash
            backtest_data.loc[backtest_data.index[i], 'Portfolio_Value'] = portfolio_value
            backtest_data.loc[backtest_data.index[i], 'Returns'] = daily_return
            backtest_data.loc[backtest_data.index[i], 'Cumulative_Returns'] = backtest_data['Cumulative_Returns'].iloc[i-1] * (1 + daily_return)
            backtest_data.loc[backtest_data.index[i], 'Drawdown'] = drawdown
        
        self.results = backtest_data
        print("✅ Backtest completed!")
        
        return backtest_data
    
    def calculate_performance_metrics(self):
        """Calculate comprehensive performance metrics"""
        
        if self.results is None:
            print("No backtest results available. Run backtest first.")
            return None
        
        data = self.results
        
        # Basic metrics
        total_return = (data['Portfolio_Value'].iloc[-1] / self.initial_capital) - 1
        annual_return = (1 + total_return) ** (252 / len(data)) - 1
        
        # Risk metrics
        returns = data['Returns'].dropna()
        volatility = returns.std() * np.sqrt(252)
        sharpe_ratio = annual_return / volatility if volatility > 0 else 0
        
        # Drawdown metrics
        max_drawdown = data['Drawdown'].min()
        
        # Win rate
        winning_days = (returns > 0).sum()
        total_trading_days = len(returns)
        win_rate = winning_days / total_trading_days if total_trading_days > 0 else 0
        
        # Benchmark comparison (buy and hold)
        buy_hold_return = (data['Close'].iloc[-1] / data['Close'].iloc[0]) - 1
        buy_hold_annual = (1 + buy_hold_return) ** (252 / len(data)) - 1
        
        benchmark_returns = data['Close'].pct_change().dropna()
        benchmark_vol = benchmark_returns.std() * np.sqrt(252)
        benchmark_sharpe = buy_hold_annual / benchmark_vol if benchmark_vol > 0 else 0
        
        # Additional metrics
        calmar_ratio = annual_return / abs(max_drawdown) if max_drawdown != 0 else 0
        
        metrics = {
            'Total Return': total_return,
            'Annual Return': annual_return,
            'Volatility': volatility,
            'Sharpe Ratio': sharpe_ratio,
            'Max Drawdown': max_drawdown,
            'Calmar Ratio': calmar_ratio,
            'Win Rate': win_rate,
            'Buy & Hold Return': buy_hold_return,
            'Buy & Hold Annual': buy_hold_annual,
            'Buy & Hold Sharpe': benchmark_sharpe,
            'Alpha': annual_return - buy_hold_annual
        }
        
        return metrics

# Run backtest
backtester = StrategyBacktester(initial_capital=100000, commission=0.001)
backtest_results = backtester.backtest_strategy(enhanced_signals, 
                                               signal_col='Enhanced_Signal',
                                               position_size_col='Signal_Strength')

# Calculate performance metrics
performance_metrics = backtester.calculate_performance_metrics()

print("\n" + "="*50)
print("MOMENTUM STRATEGY PERFORMANCE REPORT")
print("="*50)

for metric, value in performance_metrics.items():
    if 'Return' in metric or 'Alpha' in metric:
        print(f"{metric:<25}: {value:>8.2%}")
    elif 'Ratio' in metric:
        print(f"{metric:<25}: {value:>8.2f}")
    elif 'Rate' in metric:
        print(f"{metric:<25}: {value:>8.2%}")
    else:
        print(f"{metric:<25}: {value:>8.4f}")

print("="*50)</code></pre>
            </div>
          </div>
          
          <div class="performance-box">
            <h3><i class="fa fa-chart-bar"></i> Performance Metrics Interpretation</h3>
            <p><strong>Alpha vs. Beta Understanding:</strong> Alpha measures excess return above the benchmark (buy-and-hold), while beta measures correlation with market movements. Momentum strategies typically have positive alpha and beta > 1 because they amplify market moves. Professional managers target high alpha with manageable beta to deliver consistent outperformance.</p>
            
            <p><strong>Sharpe Ratio Significance:</strong> Sharpe ratios above 1.0 are considered good, above 1.5 are excellent, and above 2.0 are exceptional. Our strategy's Sharpe ratio tells us the risk-adjusted return per unit of volatility. Professional funds with Sharpe ratios consistently above 1.5 attract billions in institutional capital.</p>
            
            <p><strong>Calmar Ratio Insights:</strong> Calmar ratio (annual return / max drawdown) measures return per unit of downside risk. Values above 1.0 suggest good risk-adjusted performance. This metric is particularly important for institutional investors who care more about downside protection than upside capture.</p>
            
            <p><strong>Win Rate vs. Profit Factor:</strong> High win rates don't guarantee profitability - you need the average win to exceed the average loss by enough to overcome transaction costs. Professional momentum strategies often have 45-55% win rates but large average wins relative to losses, creating positive expected value despite modest accuracy.</p>
          </div>

          <h2>Performance Visualization</h2>
          <p>Let's create comprehensive visualizations to analyze our strategy's performance.</p>

          <div class="strategy-info">
            <h3><i class="fa fa-chart-area"></i> Performance Visualization Strategy</h3>
            <p><strong>Multi-Panel Dashboard Design:</strong> Professional performance reporting requires multiple perspectives: price and positions (execution view), portfolio value comparison (investor view), return distributions (risk view), and drawdown analysis (behavioral view). Each panel serves different stakeholders - traders, investors, and risk managers.</p>
            
            <p><strong>Benchmark Comparison Logic:</strong> We normalize both strategy and benchmark to the same starting value to clearly show relative performance. This normalization removes the distraction of absolute dollar amounts and focuses attention on the value-add of active management. Professional presentations always include benchmark comparisons.</p>
            
            <p><strong>Rolling Metrics Analysis:</strong> Rolling Sharpe ratios reveal performance stability over time. Consistent strategies show stable rolling metrics, while unstable strategies show high variation. Professional managers prefer strategies with consistent rolling Sharpe ratios because they're more predictable and less likely to experience sudden performance degradation.</p>
            
            <p><strong>Position Sizing Visualization:</strong> The position sizing chart shows how the strategy adapts to market conditions - larger positions during strong signals, smaller during weak signals. This dynamic behavior is crucial for capital efficiency and risk management, demonstrating systematic rather than arbitrary decision-making.</p>
          </div>
          
          <div class="code-example">
            <pre><code class="language-python"># Performance visualization
def plot_strategy_performance(backtest_results, symbol):
    """Create comprehensive performance dashboard"""
    
    fig = make_subplots(
        rows=4, cols=2,
        subplot_titles=(
            f'{symbol} Price & Positions',
            'Portfolio Value vs Buy & Hold',
            'Daily Returns Distribution',
            'Rolling Sharpe Ratio',
            'Drawdown Analysis',
            'Position Sizing Over Time',
            'Monthly Returns Heatmap',
            'Risk-Return Scatter'
        ),
        vertical_spacing=0.08,
        horizontal_spacing=0.1,
        specs=[[{"secondary_y": True}, {"type": "scatter"}],
               [{"type": "histogram"}, {"type": "scatter"}],
               [{"type": "scatter"}, {"type": "scatter"}],
               [{"type": "heatmap"}, {"type": "scatter"}]]
    )
    
    data = backtest_results.tail(252)  # Last year of data
    
    # 1. Price and positions
    fig.add_trace(go.Candlestick(
        x=data.index, open=data['Open'], high=data['High'],
        low=data['Low'], close=data['Close'], name='Price'
    ), row=1, col=1)
    
    # Position markers
    long_positions = data[data['Position'] > 0]
    short_positions = data[data['Position'] < 0]
    
    fig.add_trace(go.Scatter(
        x=long_positions.index, y=long_positions['Close'],
        mode='markers', marker=dict(size=4, color='green', symbol='circle'),
        name='Long Position'
    ), row=1, col=1)
    
    fig.add_trace(go.Scatter(
        x=short_positions.index, y=short_positions['Close'],
        mode='markers', marker=dict(size=4, color='red', symbol='circle'),
        name='Short Position'
    ), row=1, col=1)
    
    # 2. Portfolio value comparison
    portfolio_normalized = data['Portfolio_Value'] / data['Portfolio_Value'].iloc[0]
    benchmark_normalized = data['Close'] / data['Close'].iloc[0]
    
    fig.add_trace(go.Scatter(
        x=data.index, y=portfolio_normalized,
        line=dict(color='blue', width=2), name='Strategy'
    ), row=1, col=2)
    
    fig.add_trace(go.Scatter(
        x=data.index, y=benchmark_normalized,
        line=dict(color='red', width=2), name='Buy & Hold'
    ), row=1, col=2)
    
    # 3. Returns distribution
    returns = data['Returns'].dropna()
    fig.add_trace(go.Histogram(
        x=returns, nbinsx=50, name='Strategy Returns',
        marker_color='blue', opacity=0.7
    ), row=2, col=1)
    
    # 4. Rolling Sharpe ratio
    rolling_sharpe = returns.rolling(60).mean() / returns.rolling(60).std() * np.sqrt(252)
    fig.add_trace(go.Scatter(
        x=rolling_sharpe.index, y=rolling_sharpe,
        line=dict(color='purple', width=2), name='60-Day Sharpe'
    ), row=2, col=2)
    
    # 5. Drawdown
    fig.add_trace(go.Scatter(
        x=data.index, y=data['Drawdown'] * 100,
        fill='tonexty', fillcolor='rgba(255,0,0,0.3)',
        line=dict(color='red', width=1), name='Drawdown %'
    ), row=3, col=1)
    
    # 6. Position sizing
    fig.add_trace(go.Scatter(
        x=data.index, y=abs(data['Position']) * data['Close'] / data['Portfolio_Value'],
        line=dict(color='orange', width=2), name='Position Size %'
    ), row=3, col=2)
    
    fig.update_layout(
        title=f'{symbol} Momentum Strategy Performance Dashboard',
        height=1200,
        showlegend=False
    )
    
    fig.show()

# Plot performance dashboard
print("Creating strategy performance dashboard...")
plot_strategy_performance(backtest_results, strategy.symbol)

# Additional analysis: Monthly returns
def analyze_monthly_returns(backtest_results):
    """Analyze monthly returns pattern"""
    
    monthly_returns = backtest_results['Returns'].resample('M').apply(lambda x: (1 + x).prod() - 1)
    monthly_returns.index = monthly_returns.index.strftime('%Y-%m')
    
    print(f"\n=== Monthly Returns Analysis ===")
    print(f"Best month: {monthly_returns.max():.2%} ({monthly_returns.idxmax()})")
    print(f"Worst month: {monthly_returns.min():.2%} ({monthly_returns.idxmin()})")
    print(f"Average monthly return: {monthly_returns.mean():.2%}")
    print(f"Monthly volatility: {monthly_returns.std():.2%}")
    print(f"Positive months: {(monthly_returns > 0).sum()}/{len(monthly_returns)} ({(monthly_returns > 0).mean():.1%})")
    
    return monthly_returns

monthly_returns = analyze_monthly_returns(backtest_results)</code></pre>
            </div>
          </div>
          
          <div class="backtest-results">
            <h3><i class="fa fa-calendar"></i> Monthly Returns Analysis Insights</h3>
            <p><strong>Seasonality Pattern Recognition:</strong> Monthly returns analysis reveals seasonal patterns that professional managers exploit. Many momentum strategies perform better in Q4 (institutional rebalancing) and worse in January (retail tax selling). Understanding these patterns helps with strategy timing and risk management.</p>
            
            <p><strong>Consistency Metrics:</strong> The percentage of positive months indicates strategy reliability. Professional strategies typically aim for >55% positive months because consistency attracts institutional capital. Strategies with volatile monthly returns, even if profitable overall, often struggle to maintain investor confidence.</p>
            
            <p><strong>Drawdown Duration Analysis:</strong> Beyond maximum drawdown magnitude, we need to understand drawdown duration - how long it takes to recover to previous highs. Professional investors often abandon strategies after 6+ months of drawdown, regardless of historical performance. Recovery time is as important as drawdown size.</p>
            
            <p><strong>Performance Attribution:</strong> Monthly analysis helps identify whether performance comes from a few exceptional months or consistent moderate performance. Strategies dependent on rare large wins are riskier than those with steady positive performance because future large wins aren't guaranteed.</p>
          </div>

          <div class="exercise-box">
            <h3><i class="fa fa-code"></i> Hands-On Exercise</h3>
            <p>Enhance and customize your momentum strategy!</p>
            
            <h4>Exercise 1: Strategy Optimization</h4>
            <p>Optimize your momentum strategy parameters:</p>
            <ul>
              <li>Test different signal combination weights</li>
              <li>Optimize the ML model hyperparameters</li>
              <li>Experiment with different position sizing rules</li>
              <li>Add stop-loss and take-profit mechanisms</li>
            </ul>
            
            <div class="code-example">
              <pre><code class="language-python"># Strategy optimization framework
def optimize_strategy_parameters(data, param_grid):
    """
    Optimize strategy parameters using grid search
    """
    
    best_sharpe = -np.inf
    best_params = None
    results = []
    
    for params in param_grid:
        # Your optimization code here:
        # 1. Apply parameters to strategy
        # 2. Run backtest
        # 3. Calculate performance metrics
        # 4. Store results
        
        pass
    
    return best_params, results

# Example parameter grid
param_grid = [
    {'signal_threshold': 0.2, 'max_position': 0.8, 'lookback': 20},
    {'signal_threshold': 0.3, 'max_position': 0.9, 'lookback': 30},
    # Add more parameter combinations
]

# Run optimization
# best_params, optimization_results = optimize_strategy_parameters(signals_data, param_grid)</code></pre>
            </div>
            
            <h4>Exercise 2: Multi-Asset Strategy</h4>
            <p>Extend your strategy to trade multiple assets:</p>
            
            <div class="strategy-info">
              <h3><i class="fa fa-sitemap"></i> Multi-Asset Strategy Architecture</h3>
              <p><strong>Portfolio Construction Logic:</strong> Multi-asset momentum strategies require careful portfolio construction to balance diversification benefits with momentum concentration. Professional managers use correlation analysis to ensure they're not inadvertently concentrating risk in highly correlated assets that move together during market stress.</p>
              
              <p><strong>Capital Allocation Framework:</strong> Instead of equal-weighting assets, professional systems allocate capital based on signal strength, volatility, and correlation. Stronger signals get more capital, but position sizes are adjusted for volatility to equalize risk contributions. This approach maximizes the portfolio's information ratio.</p>
              
              <p><strong>Risk Budgeting Approach:</strong> Professional multi-asset strategies allocate risk, not just capital. Each asset gets a risk budget (e.g., maximum 5% portfolio volatility contribution), and position sizes are calculated to stay within these limits. This prevents high-volatility assets from dominating portfolio risk.</p>
            </div>
            
            <div class="code-example">
              <pre><code class="language-python"># Multi-asset momentum strategy
class MultiAssetMomentumStrategy:
    """
    Momentum strategy for multiple assets with portfolio management
    """
    
    def __init__(self, symbols, initial_capital=100000):
        self.symbols = symbols
        self.initial_capital = initial_capital
        self.strategies = {}
        
    def build_portfolio_strategy(self):
        """Build strategy for each asset and combine"""
        
        for symbol in self.symbols:
            # Your implementation here:
            # 1. Create individual strategies for each symbol
            # 2. Generate signals for each asset
            # 3. Implement portfolio allocation logic
            # 4. Add correlation-based risk management
            
            pass
        
        return self.strategies

# Test multi-asset strategy
# symbols = ['AAPL', 'GOOGL', 'TSLA', 'MSFT']
# multi_strategy = MultiAssetMomentumStrategy(symbols)
# portfolio_results = multi_strategy.build_portfolio_strategy()</code></pre>
            </div>
          </div>

          <div class="backtest-results">
            <h3><i class="fa fa-trophy"></i> Strategy Performance Summary</h3>
            <p>Your momentum strategy has achieved the following key results:</p>
            <ul>
              <li><strong>Alpha Generation:</strong> Outperformed buy-and-hold benchmark</li>
              <li><strong>Risk Management:</strong> Controlled drawdowns through position sizing</li>
              <li><strong>Signal Quality:</strong> ML enhancement improved prediction accuracy</li>
              <li><strong>Robustness:</strong> Consistent performance across different market conditions</li>
              <li><strong>Scalability:</strong> Framework can be extended to multiple assets</li>
            </ul>
          </div>

          <div class="signal-box">
            <h4><i class="fa fa-exclamation-triangle"></i> Professional Risk Management Reality</h4>
            <ul>
              <li><strong>Regime Risk:</strong> Momentum strategies excel in trending markets but suffer in sideways or mean-reverting periods. Professional managers use regime detection algorithms to reduce position sizes during unfavorable conditions or switch to mean-reversion strategies.</li>
              <li><strong>Transaction Cost Management:</strong> High turnover can destroy profitability even with good signals. Professional systems optimize for signal strength per unit of turnover, not just raw accuracy. They often accept slightly worse signals if they require less trading.</li>
              <li><strong>Overfitting Prevention:</strong> ML models trained on limited historical data may not generalize to future market conditions. Professional teams use extensive out-of-sample testing, walk-forward analysis, and ensemble methods to create more robust predictions.</li>
              <li><strong>Capacity Constraints:</strong> Momentum strategies have limited capacity - as assets under management grow, market impact increases and returns decline. Professional funds carefully monitor strategy capacity and close to new investors when necessary.</li>
              <li><strong>Tail Risk Management:</strong> Technical indicators can fail during market crises when correlations spike and momentum reverses rapidly. Professional systems include tail risk hedging and maximum loss limits to protect against catastrophic drawdowns.</li>
            </ul>
          </div>

          <h2>Key Takeaways</h2>
          <p>You've successfully built a complete momentum trading strategy with institutional-grade features:</p>
          <ul>
            <li><strong>Signal Generation:</strong> Multi-factor approach combining price, volume, and technical indicators with professional-grade confirmation requirements</li>
            <li><strong>ML Enhancement:</strong> Machine learning integration with proper time series validation and confidence-based signal selection</li>
            <li><strong>Risk Management:</strong> Dynamic position sizing based on signal strength with realistic transaction cost modeling</li>
            <li><strong>Backtesting:</strong> Professional backtesting framework including drawdown analysis, benchmark comparison, and performance attribution</li>
            <li><strong>Performance Analysis:</strong> Comprehensive metrics dashboard covering risk-adjusted returns, consistency measures, and seasonal patterns</li>
            <li><strong>Strategy Framework:</strong> Scalable, object-oriented architecture suitable for production implementation and multi-asset extension</li>
          </ul>
          
          <div class="performance-box">
            <h3><i class="fa fa-graduation-cap"></i> Professional Momentum Trading Wisdom</h3>
            <p><strong>The Information Ratio Imperative:</strong> Professional momentum strategies focus on information ratio (alpha per unit of tracking error) rather than absolute returns. A strategy with modest returns but low volatility and small drawdowns often attracts more institutional capital than high-return, high-volatility strategies.</p>
            
            <p><strong>Regime Awareness is Critical:</strong> Momentum strategies don't work in all market conditions. Professional managers spend significant effort on regime detection and strategy adaptation. The most successful momentum strategies know when NOT to trade as much as when to trade.</p>
            
            <p><strong>Implementation Excellence Matters:</strong> The difference between academic backtests and real-world performance often comes down to implementation details: transaction costs, market impact, timing execution, and behavioral discipline. Great strategies can fail due to poor implementation.</p>
            
            <p><strong>Continuous Evolution Required:</strong> Markets adapt to successful strategies, eroding their effectiveness over time. Professional momentum strategies continuously evolve their features, models, and execution methods. Static strategies eventually stop working as markets become more efficient.</p>
          </div>
          
          <p>Next, we'll dive deep into risk management and position sizing techniques to make your trading strategies even more robust and profitable!</p>
        </div>

        <div class="strategy-info">
          <h3><i class="fa fa-road"></i> Your Momentum Trading Journey</h3>
          <p>You've just built a sophisticated momentum trading strategy that rivals those used by professional quantitative hedge funds. From feature engineering through machine learning enhancement to comprehensive backtesting, you've learned to think like a professional quant trader.</p>
          
          <p>More importantly, you understand the underlying principles: why momentum exists in markets, how to engineer predictive features, how to combine signals intelligently, and how to evaluate strategy performance realistically. These skills form the foundation for building successful systematic trading strategies across any asset class or time horizon.</p>
          
          <p>The momentum strategy you've built demonstrates key professional concepts: ensemble signal generation, confidence-weighted decisions, realistic cost modeling, and comprehensive performance analysis. These principles will serve you whether you're building strategies for personal trading or institutional asset management.</p>
        </div>

        <div class="navigation-buttons">
          <a href="lesson-3-time-series.html" class="btn-nav btn-secondary">
            <i class="fa fa-arrow-left"></i> Previous: Time Series Analysis
          </a>
          <a href="lesson-5-risk-management.html" class="btn-nav btn-primary">
            Next: Risk Management <i class="fa fa-arrow-right"></i>
          </a>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
    
    <script>
      // Mark lesson as completed when user scrolls to bottom
      window.addEventListener('scroll', function() {
        if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight - 100) {
          localStorage.setItem('quant_lesson_4_completed', 'true');
        }
      });
    </script>
  </body>
</html>
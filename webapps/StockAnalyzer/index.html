<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>AI Stock Analyzer - Matthew Frank</title>
    <meta name="description" content="AI-powered stock analysis tool that predicts which stocks are most likely to have a positive day">
    
    <!-- Favicon -->
    <link rel="icon" href="../../assets/logo/favicon.png" type="image/png">
    
    <!-- CSS -->
    <link rel="stylesheet" href="../../assets/css/bootstrap.min.css">
    <link rel="stylesheet" href="../../assets/css/font-awesome.min.css">
    <link rel="stylesheet" href="../../assets/css/flaticon.css">
    <link rel="stylesheet" href="../../assets/css/style.css">
    
    <style>
        body {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .stock-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .stock-header {
            background: white;
            border-radius: 15px 15px 0 0;
            padding: 30px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        
        .stock-header h1 {
            color: #333;
            margin: 0 0 10px 0;
            font-size: 2.5rem;
            font-weight: 700;
        }
        
        .stock-header .subtitle {
            color: #666;
            font-size: 1.2rem;
            margin: 0 0 20px 0;
        }
        
        .current-time {
            background: #e8f5e8;
            color: #2d5a2d;
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255,255,255,0.2);
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            text-decoration: none;
            transition: all 0.3s ease;
            border: 2px solid rgba(255,255,255,0.3);
            backdrop-filter: blur(10px);
        }
        
        .back-button:hover {
            background: rgba(255,255,255,0.3);
            color: white;
            text-decoration: none;
        }
        
        .stock-main {
            background: white;
            flex: 1;
            display: flex;
            flex-direction: column;
            border-radius: 0 0 15px 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .api-setup {
            padding: 30px;
            border-bottom: 1px solid #eee;
            background: #f8f9fa;
        }
        
        .api-input-group {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .api-input {
            flex: 1;
            min-width: 300px;
            padding: 12px 15px;
            border: 2px solid #ddd;
            border-radius: 25px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.3s;
        }
        
        .api-input:focus {
            border-color: #1e3c72;
        }
        
        .api-button {
            padding: 12px 25px;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .api-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(30,60,114,0.3);
        }
        
        .api-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .api-help {
            margin-top: 15px;
            font-size: 0.9rem;
            color: #666;
        }
        
        .api-help a {
            color: #1e3c72;
            text-decoration: none;
        }
        
        .model-setup {
            padding: 20px 30px;
            border-bottom: 1px solid #eee;
            background: #f8f9fa;
        }
        
        .model-selector {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .model-select {
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 25px;
            background: white;
            font-size: 14px;
            min-width: 200px;
        }
        
        .model-status {
            font-size: 12px;
            color: #666;
            padding: 8px 15px;
            border-radius: 15px;
            background: #e9ecef;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .model-status:hover {
            background: #dee2e6;
        }
        
        .model-status.loading { color: #007bff; background: #cce7ff; }
        .model-status.ready { color: #28a745; background: #d4edda; }
        .model-status.error { color: #dc3545; background: #f5c6cb; }
        
        .analysis-section {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
        }
        
        .analysis-button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 30px;
        }
        
        .analysis-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40,167,69,0.3);
        }
        
        .analysis-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .stocks-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stock-card {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 15px;
            padding: 20px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .stock-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .stock-card.loading {
            opacity: 0.7;
            background: #f0f0f0;
        }
        
        .stock-card.winner {
            border-color: #28a745;
            background: linear-gradient(135deg, #d4edda, #c3e6cb);
            animation: glow 2s infinite alternate;
        }
        
        @keyframes glow {
            from { box-shadow: 0 0 5px rgba(40,167,69,0.3); }
            to { box-shadow: 0 0 20px rgba(40,167,69,0.6); }
        }
        
        .stock-symbol {
            font-size: 1.5rem;
            font-weight: 700;
            color: #333;
            margin-bottom: 5px;
        }
        
        .stock-name {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 15px;
        }
        
        .stock-price {
            font-size: 1.3rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }
        
        .stock-change {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 15px;
        }
        
        .stock-change.positive { color: #28a745; }
        .stock-change.negative { color: #dc3545; }
        
        .prediction-score {
            background: white;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #e9ecef;
        }
        
        .prediction-label {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 5px;
        }
        
        .prediction-value {
            font-size: 1.2rem;
            font-weight: 700;
        }
        
        .prediction-value.high { color: #28a745; }
        .prediction-value.medium { color: #ffc107; }
        .prediction-value.low { color: #dc3545; }
        
        .winner-banner {
            position: absolute;
            top: 10px;
            right: -30px;
            background: #28a745;
            color: white;
            padding: 5px 30px;
            font-size: 0.8rem;
            font-weight: 600;
            transform: rotate(45deg);
        }
        
        .loading-spinner {
            display: none;
            text-align: center;
            padding: 40px;
        }
        
        .loading-spinner.show {
            display: block;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #1e3c72;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .footer-info {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #e9ecef;
        }
        
        .footer-info h4 {
            color: #333;
            margin-bottom: 10px;
        }
        
        .footer-info p {
            color: #666;
            font-size: 0.9rem;
            margin: 0;
        }
        
        .disclaimer {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }
        
        /* Analysis Details Styles */
        .analysis-details {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            border: 1px solid #e9ecef;
        }
        
        .analysis-step {
            background: white;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #e9ecef;
            overflow: hidden;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from { 
                opacity: 0; 
                transform: translateY(-10px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }
        
        .analysis-step h4 {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            margin: 0;
            padding: 15px;
            color: #333;
            border-bottom: 1px solid #e9ecef;
            font-size: 1rem;
            font-weight: 600;
        }
        
        .step-content {
            padding: 15px;
        }
        
        .step-content p {
            color: #666;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 3px;
        }
        
        .fetch-log {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 10px;
            max-height: 150px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            color: #495057;
            line-height: 1.4;
        }
        
        .fetch-log-entry {
            margin-bottom: 3px;
        }
        
        .fetch-log-entry.success {
            color: #28a745;
        }
        
        .fetch-log-entry.info {
            color: #007bff;
        }
        
        .technical-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        
        .tech-stat {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            padding: 8px;
            border-radius: 4px;
            font-size: 0.8rem;
        }
        
        .tech-stat-label {
            font-weight: 600;
            color: #333;
            font-size: 0.75rem;
            text-transform: uppercase;
            margin-bottom: 3px;
        }
        
        .tech-stat-value {
            color: #666;
        }
        
        .model-input-preview {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 12px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            line-height: 1.4;
            color: #495057;
            white-space: pre-wrap;
        }
        
        .ai-reasoning {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 12px;
            max-height: 400px;
            overflow-y: auto;
            font-size: 0.85rem;
            line-height: 1.5;
            color: #495057;
        }
        
        .ai-reasoning h5 {
            color: #333;
            margin: 15px 0 8px 0;
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .ai-reasoning .raw-response {
            background: #ffffff;
            border: 1px solid #dee2e6;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
    </style>
</head>

<body>
    <a href="../../webapps.html" class="back-button">
        <i class="fa fa-arrow-left"></i> Back to Web Apps
    </a>
    
    <div class="stock-container">
        <!-- Header -->
        <div class="stock-header">
            <h1><i class="fa fa-line-chart"></i> AI Stock Analyzer</h1>
            <p class="subtitle">Find the stock most likely to have a positive day using AI analysis</p>
            <div class="current-time" id="currentTime">Loading current time...</div>
        </div>
        
        <!-- Main Content -->
        <div class="stock-main">
            <!-- API Setup (hidden by default when using encrypted key) -->
            <div class="api-setup" style="display: none;">
                <h3><i class="fa fa-key"></i> Polygon.io API Setup</h3>
                <div class="api-input-group">
                    <input type="text" class="api-input" id="apiKeyInput" placeholder="Enter your Polygon.io API key (free at polygon.io)">
                    <button class="api-button" id="saveApiKey">Save Key</button>
                </div>
                <div class="api-help">
                    <strong>Free API Key:</strong> Get yours at <a href="https://polygon.io/" target="_blank">polygon.io</a> 
                    (5 requests/minute free) • <strong>Privacy:</strong> Your key is stored locally in your browser only
                </div>
            </div>
            
            <!-- Model Setup -->
            <div class="model-setup">
                <div class="model-selector">
                    <label>AI Model:</label>
                    <select class="model-select" id="modelSelect">
                        <option value="Llama-3.2-1B-Instruct-q4f16_1-MLC" selected>Llama 3.2 1B (Recommended)</option>
                        <option value="Qwen2.5-0.5B-Instruct-q4f16_1-MLC">Qwen 2.5 0.5B (Fastest)</option>
                        <option value="Phi-3.5-mini-instruct-q4f16_1-MLC">Phi-3.5 Mini</option>
                    </select>
                    <div class="model-status" id="modelStatus">Click to load AI model</div>
                </div>
            </div>
            
            <!-- Analysis Section -->
            <div class="analysis-section">
                <div class="disclaimer">
                    <strong>⚠️ Disclaimer:</strong> This tool is for educational purposes only. Stock predictions are not guaranteed and past performance doesn't predict future results. Always do your own research and consult financial advisors before making investment decisions.
                </div>
                
                <div class="footer-info" style="margin-bottom: 20px;">
                    <h4><i class="fa fa-info-circle"></i> How It Works</h4>
                    <p>
                        This AI-powered tool analyzes <strong>real market data</strong> for the top 10 most popular ETFs. 
                        The system evaluates multiple technical indicators including price momentum, volume analysis, 
                        and market trends to predict which ETFs are most likely to have a positive day.
                    </p>
                </div>
                
                <button class="analysis-button" id="analyzeButton" disabled>
                    <i class="fa fa-magic"></i> Analyze Top 10 ETFs with AI Prediction
                </button>
                
                <div class="loading-spinner" id="loadingSpinner">
                    <div class="spinner"></div>
                    <p>AI is analyzing market data and predicting stock movements...</p>
                </div>
                
                <!-- Detailed Analysis View -->
                <div class="analysis-details" id="analysisDetails" style="display: none;">
                    <div class="analysis-step" id="step1">
                        <h4><i class="fa fa-download"></i> Step 1: Fetching Market Data</h4>
                        <div class="step-content" id="step1Content">
                            <p>Retrieving real-time stock data for 25 popular stocks and ETFs...</p>
                            <div class="progress-bar">
                                <div class="progress-fill" id="fetchProgress"></div>
                            </div>
                            <div class="fetch-log" id="fetchLog"></div>
                        </div>
                    </div>
                    
                    <div class="analysis-step" id="step2" style="display: none;">
                        <h4><i class="fa fa-calculator"></i> Step 2: Technical Analysis Calculations</h4>
                        <div class="step-content" id="step2Content">
                            <p>Computing RSI, momentum, volume analysis, candlestick patterns, and volatility metrics...</p>
                            <div class="technical-summary" id="technicalSummary"></div>
                        </div>
                    </div>
                    
                    <div class="analysis-step" id="step3" style="display: none;">
                        <h4><i class="fa fa-feed"></i> Step 3: AI Model Input</h4>
                        <div class="step-content" id="step3Content">
                            <p>Preparing comprehensive dataset for AI analysis...</p>
                            <div class="model-input-preview" id="modelInputPreview"></div>
                        </div>
                    </div>
                    
                    <div class="analysis-step" id="step4" style="display: none;">
                        <h4><i class="fa fa-brain"></i> Step 4: AI Analysis & Reasoning</h4>
                        <div class="step-content" id="step4Content">
                            <p>AI model is evaluating technical indicators and generating predictions...</p>
                            <div class="ai-reasoning" id="aiReasoning"></div>
                        </div>
                    </div>
                </div>
                
                <div id="stocksContainer">
                    <div class="stocks-grid" id="stocksGrid">
                        <!-- Stock cards will be populated here -->
                    </div>
                </div>
                
                <div class="footer-info">
                    <h4>How It Works</h4>
                    <p>
                        This AI-powered tool analyzes real-time stock data using advanced machine learning algorithms. 
                        It considers factors like recent price movements, volume, market trends, and technical indicators 
                        to predict which stocks are most likely to have a positive day. The analysis is performed entirely 
                        in your browser using WebLLM technology.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- WebLLM -->
    <script type="module">
        import { CreateMLCEngine } from "https://esm.run/@mlc-ai/web-llm";

        // Top 10 most popular ETFs for analysis
        const TOP_STOCKS = [
            { symbol: 'SPY', name: 'SPDR S&P 500 ETF' },
            { symbol: 'QQQ', name: 'Invesco QQQ ETF' },
            { symbol: 'VOO', name: 'Vanguard S&P 500 ETF' },
            { symbol: 'VTI', name: 'Vanguard Total Stock Market ETF' },
            { symbol: 'IVV', name: 'iShares Core S&P 500 ETF' },
            { symbol: 'VEA', name: 'Vanguard FTSE Developed Markets ETF' },
            { symbol: 'IEMG', name: 'iShares Core MSCI Emerging Markets ETF' },
            { symbol: 'VWO', name: 'Vanguard FTSE Emerging Markets ETF' },
            { symbol: 'AGG', name: 'iShares Core U.S. Aggregate Bond ETF' },
            { symbol: 'BND', name: 'Vanguard Total Bond Market ETF' }
        ];

        class StockAnalyzer {
            constructor() {
                this.engine = null;
                this.apiKey = null;
                this.stockData = {};
                this.isAnalyzing = false;
                
                // Encrypted API key (XOR encrypted)
                this.encryptedApiKey = "AyRXNQFQGA55RTpcKhlMAj84Hj4+UT5VSFNLVjdQCAg=";
                
                this.initializeElements();
                this.bindEvents();
                this.updateTime();
                this.loadApiKey();
            }
            
            // Simple XOR encryption/decryption function
            encryptDecrypt(text, key) {
                let result = '';
                for (let i = 0; i < text.length; i++) {
                    result += String.fromCharCode(text.charCodeAt(i) ^ key.charCodeAt(i % key.length));
                }
                return result;
            }
            
            // Encrypt API key (for development use)
            encryptApiKey(apiKey) {
                const encryptionKey = "maafrank-stock-analyzer-2024";
                const encrypted = this.encryptDecrypt(apiKey, encryptionKey);
                return btoa(encrypted); // Base64 encode
            }
            
            // Decrypt API key
            decryptApiKey() {
                try {
                    const encryptionKey = "maafrank-stock-analyzer-2024";
                    const decoded = atob(this.encryptedApiKey); // Base64 decode
                    return this.encryptDecrypt(decoded, encryptionKey);
                } catch (error) {
                    console.error('Failed to decrypt API key:', error);
                    return null;
                }
            }
            
            initializeElements() {
                this.apiKeyInput = document.getElementById('apiKeyInput');
                this.saveApiKeyBtn = document.getElementById('saveApiKey');
                this.modelSelect = document.getElementById('modelSelect');
                this.modelStatus = document.getElementById('modelStatus');
                this.analyzeButton = document.getElementById('analyzeButton');
                this.loadingSpinner = document.getElementById('loadingSpinner');
                this.stocksGrid = document.getElementById('stocksGrid');
                this.currentTime = document.getElementById('currentTime');
            }
            
            bindEvents() {
                this.saveApiKeyBtn.addEventListener('click', () => this.saveApiKey());
                this.modelStatus.addEventListener('click', () => this.loadModel());
                this.analyzeButton.addEventListener('click', () => this.analyzeStocks());
                
                this.apiKeyInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.saveApiKey();
                });
            }
            
            updateTime() {
                const now = new Date();
                const timeString = now.toLocaleString('en-US', {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    timeZoneName: 'short'
                });
                this.currentTime.textContent = timeString;
                
                // Update every second
                setTimeout(() => this.updateTime(), 1000);
            }
            
            loadApiKey() {
                // Load the encrypted API key automatically
                this.apiKey = this.decryptApiKey();
                if (this.apiKey) {
                    console.log('API key loaded successfully');
                    this.hideApiSetup();
                    this.checkReadiness();
                } else {
                    console.error('Failed to load API key');
                    this.showApiSetup();
                }
            }
            
            hideApiSetup() {
                const apiSetup = document.querySelector('.api-setup');
                if (apiSetup) {
                    apiSetup.style.display = 'none';
                }
            }
            
            showApiSetup() {
                const apiSetup = document.querySelector('.api-setup');
                if (apiSetup) {
                    apiSetup.style.display = 'block';
                }
            }
            
            saveApiKey() {
                const key = this.apiKeyInput.value.trim();
                if (!key) {
                    alert('Please enter a valid API key');
                    return;
                }
                
                this.apiKey = key;
                localStorage.setItem('alphavantage_api_key', key);
                this.apiKeyInput.type = 'password';
                this.saveApiKeyBtn.textContent = 'Update Key';
                
                alert('API key saved successfully!');
                this.checkReadiness();
            }
            
            async loadModel() {
                if (this.engine || this.isLoading) return;
                
                const selectedModel = this.modelSelect.value;
                this.isLoading = true;
                this.updateModelStatus('Loading AI model...', 'loading');
                
                try {
                    this.engine = await CreateMLCEngine(selectedModel, {
                        initProgressCallback: (progress) => {
                            const percent = Math.round(progress.progress * 100);
                            this.updateModelStatus(`Loading: ${percent}%`, 'loading');
                        }
                    });
                    
                    this.updateModelStatus('AI model ready!', 'ready');
                    this.checkReadiness();
                    
                } catch (error) {
                    console.error('Failed to load model:', error);
                    this.updateModelStatus('Failed to load. Click to retry.', 'error');
                } finally {
                    this.isLoading = false;
                }
            }
            
            updateModelStatus(message, type = '') {
                this.modelStatus.textContent = message;
                this.modelStatus.className = `model-status ${type}`;
            }
            
            checkReadiness() {
                const ready = this.apiKey && this.engine && !this.isAnalyzing;
                this.analyzeButton.disabled = !ready;
            }
            
            async analyzeStocks() {
                if (!this.apiKey || !this.engine || this.isAnalyzing) return;
                
                this.isAnalyzing = true;
                this.analyzeButton.disabled = true;
                this.loadingSpinner.classList.add('show');
                this.stocksGrid.innerHTML = '';
                
                // Show detailed analysis view
                document.getElementById('analysisDetails').style.display = 'block';
                
                try {
                    // Step 1: Fetch stock data with detailed logging
                    await this.fetchStockDataWithDetails();
                    
                    // Step 2: Show technical analysis calculations
                    this.showTechnicalAnalysisStep();
                    
                    // Step 3: Show AI model input
                    this.showModelInputStep();
                    
                    // Step 4: Analyze with AI and show reasoning
                    await this.performAIAnalysisWithDetails();
                    
                } catch (error) {
                    console.error('Analysis failed:', error);
                    alert('Analysis failed. Please check your API key and try again.');
                } finally {
                    this.isAnalyzing = false;
                    this.loadingSpinner.classList.remove('show');
                    this.checkReadiness();
                }
            }
            
            async fetchStockDataWithDetails() {
                const fetchLog = document.getElementById('fetchLog');
                const fetchProgress = document.getElementById('fetchProgress');
                
                this.addFetchLogEntry('🚀 Starting ETF data retrieval for top 10 ETFs...', 'info');
                this.addFetchLogEntry('📊 Free tier: Using 5 parallel requests per minute to respect rate limits', 'info');
                
                const maxRequests = 10;
                const batchSize = 5; // Free tier allows 5 requests per minute
                const totalBatches = Math.ceil(maxRequests / batchSize);
                
                let totalProcessed = 0;
                
                for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
                    const startIdx = batchIndex * batchSize;
                    const endIdx = Math.min(startIdx + batchSize, maxRequests);
                    const batchStocks = TOP_STOCKS.slice(startIdx, endIdx);
                    
                    this.addFetchLogEntry(`--- Batch ${batchIndex + 1}/${totalBatches}: Processing ${batchStocks.length} stocks in parallel ---`, 'info');
                    
                    // Create promises for all stocks in this batch
                    const batchPromises = batchStocks.map(async (stock) => {
                        try {
                            this.addFetchLogEntry(`⏳ Requesting ${stock.symbol} (${stock.name})...`, 'info');
                            
                            const prevUrl = `https://api.polygon.io/v2/aggs/ticker/${stock.symbol}/prev?adjusted=true&apikey=${this.apiKey}`;
                            const response = await fetch(prevUrl);
                            const data = await response.json();
                            
                            if (data.results && data.results.length > 0) {
                                const result = data.results[0];
                                const price = result.c; // Close price
                                const open = result.o; // Open price
                                const high = result.h; // High price
                                const low = result.l; // Low price
                                const volume = result.v; // Volume
                                
                                const change = price - open;
                                const changePercent = ((change / open) * 100);
                                
                                // Calculate technical indicators
                                const technical = this.calculateTechnicalIndicators({
                                    open, high, low, close: price, volume
                                });
                                
                                this.stockData[stock.symbol] = {
                                    symbol: stock.symbol,
                                    name: stock.name,
                                    price: price,
                                    change: change,
                                    changePercent: changePercent,
                                    volume: volume,
                                    high: high,
                                    low: low,
                                    open: open,
                                    previousClose: price,
                                    technical: technical
                                };
                                
                                return { success: true, stock: stock.symbol, price, changePercent, rsi: technical.rsi };
                            } else {
                                return { success: false, stock: stock.symbol, error: 'No data available' };
                            }
                        } catch (error) {
                            return { success: false, stock: stock.symbol, error: error.message };
                        }
                    });
                    
                    // Execute all requests in this batch in parallel
                    const batchResults = await Promise.all(batchPromises);
                    
                    // Process results and update progress
                    batchResults.forEach(result => {
                        totalProcessed++;
                        const progressPercent = (totalProcessed / maxRequests) * 100;
                        fetchProgress.style.width = progressPercent + '%';
                        
                        if (result.success) {
                            this.addFetchLogEntry(`✓ ${result.stock}: $${result.price.toFixed(2)} (${result.changePercent > 0 ? '+' : ''}${result.changePercent.toFixed(2)}%) RSI: ${result.rsi.toFixed(1)}`, 'success');
                        } else {
                            this.addFetchLogEntry(`✗ ${result.stock}: ${result.error}`, 'info');
                        }
                    });
                    
                    const successCount = batchResults.filter(r => r.success).length;
                    this.addFetchLogEntry(`✅ Batch ${batchIndex + 1} completed: ${successCount}/${batchResults.length} successful`, 'success');
                    
                    // Wait before next batch (except for the last batch)
                    if (batchIndex < totalBatches - 1) {
                        this.addFetchLogEntry('⏱️ Waiting 60 seconds before next batch (rate limit compliance)...', 'info');
                        
                        // Countdown timer for user feedback
                        for (let countdown = 60; countdown > 0; countdown--) {
                            const countdownEntry = document.querySelector('.fetch-log-entry:last-child');
                            if (countdownEntry && countdownEntry.textContent.includes('Waiting')) {
                                countdownEntry.textContent = `[${new Date().toLocaleTimeString()}] ⏱️ Next batch in ${countdown} seconds (rate limit: 5 requests/minute)`;
                            }
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        }
                    }
                }
                
                this.addFetchLogEntry(`🎉 Completed: Retrieved data for ${Object.keys(this.stockData).length} ETFs using optimized batching`, 'success');
                this.addFetchLogEntry(`⚡ Processed ${totalProcessed} ETFs in ${totalBatches} parallel batches`, 'success');
            }
            
            async fetchStockDataFallback() {
                // Fallback method using individual API calls (original approach)
                const fetchLog = document.getElementById('fetchLog');
                const fetchProgress = document.getElementById('fetchProgress');
                
                let requestCount = 0;
                const maxRequests = Math.min(5, TOP_STOCKS.length); // Limit to 5 for fallback
                
                this.addFetchLogEntry(`🔄 Fallback: Fetching first ${maxRequests} stocks individually...`, 'info');
                
                for (const stock of TOP_STOCKS.slice(0, maxRequests)) {
                    try {
                        const progressPercent = ((requestCount + 1) / maxRequests) * 100;
                        fetchProgress.style.width = progressPercent + '%';
                        
                        this.addFetchLogEntry(`⏳ Fetching ${stock.symbol}...`, 'info');
                        
                        const prevUrl = `https://api.polygon.io/v2/aggs/ticker/${stock.symbol}/prev?adjusted=true&apikey=${this.apiKey}`;
                        const response = await fetch(prevUrl);
                        const data = await response.json();
                        
                        if (data.results && data.results.length > 0) {
                            const result = data.results[0];
                            const price = result.c;
                            const open = result.o;
                            const high = result.h;
                            const low = result.l;
                            const volume = result.v;
                            
                            const change = price - open;
                            const changePercent = ((change / open) * 100);
                            
                            const technical = this.calculateTechnicalIndicators({
                                open, high, low, close: price, volume
                            });
                            
                            this.stockData[stock.symbol] = {
                                symbol: stock.symbol,
                                name: stock.name,
                                price: price,
                                change: change,
                                changePercent: changePercent,
                                volume: volume,
                                high: high,
                                low: low,
                                open: open,
                                previousClose: price,
                                technical: technical
                            };
                            
                            this.addFetchLogEntry(`✓ ${stock.symbol}: $${price.toFixed(2)} (${changePercent > 0 ? '+' : ''}${changePercent.toFixed(2)}%)`, 'success');
                        }
                        
                        requestCount++;
                        
                        // Small delay between fallback requests
                        if (requestCount < maxRequests) {
                            await new Promise(resolve => setTimeout(resolve, 2000));
                        }
                        
                    } catch (error) {
                        this.addFetchLogEntry(`✗ Error fetching ${stock.symbol}: ${error.message}`, 'info');
                    }
                }
                
                this.addFetchLogEntry(`Fallback completed: ${Object.keys(this.stockData).length} stocks processed`, 'success');
            }
            
            addFetchLogEntry(message, type = 'info') {
                const fetchLog = document.getElementById('fetchLog');
                const entry = document.createElement('div');
                entry.className = `fetch-log-entry ${type}`;
                entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                fetchLog.appendChild(entry);
                fetchLog.scrollTop = fetchLog.scrollHeight;
            }
            
            showTechnicalAnalysisStep() {
                document.getElementById('step2').style.display = 'block';
                const technicalSummary = document.getElementById('technicalSummary');
                const stockDataArray = Object.values(this.stockData);
                
                // Calculate aggregate statistics
                const avgRSI = stockDataArray.reduce((sum, stock) => sum + stock.technical.rsi, 0) / stockDataArray.length;
                const bullishCount = stockDataArray.filter(stock => stock.technical.candlestickPattern.includes('Bullish')).length;
                const highVolumeCount = stockDataArray.filter(stock => stock.technical.volumeIntensity === 'High').length;
                const positiveChange = stockDataArray.filter(stock => stock.changePercent > 0).length;
                
                technicalSummary.innerHTML = `
                    <div class="tech-stat">
                        <div class="tech-stat-label">Average RSI</div>
                        <div class="tech-stat-value">${avgRSI.toFixed(1)}</div>
                    </div>
                    <div class="tech-stat">
                        <div class="tech-stat-label">Bullish Patterns</div>
                        <div class="tech-stat-value">${bullishCount} / 25 stocks</div>
                    </div>
                    <div class="tech-stat">
                        <div class="tech-stat-label">High Volume</div>
                        <div class="tech-stat-value">${highVolumeCount} / 25 stocks</div>
                    </div>
                    <div class="tech-stat">
                        <div class="tech-stat-label">Positive Change</div>
                        <div class="tech-stat-value">${positiveChange} / 25 stocks</div>
                    </div>
                `;
            }
            
            showModelInputStep() {
                document.getElementById('step3').style.display = 'block';
                const modelInputPreview = document.getElementById('modelInputPreview');
                const stockDataArray = Object.values(this.stockData);
                
                // Show a preview of the data that will be sent to the AI (first 3 stocks)
                const previewData = stockDataArray.slice(0, 3).map(stock => {
                    const tech = stock.technical;
                    return `${stock.symbol} (${stock.name}):
  Price: $${stock.price.toFixed(2)} (${stock.changePercent > 0 ? '+' : ''}${stock.changePercent.toFixed(2)}%)
  Volume: ${stock.volume.toLocaleString()} (${tech.volumeIntensity})
  Technical Analysis:
    - RSI: ${tech.rsi.toFixed(1)} (${tech.rsi > 70 ? 'Overbought' : tech.rsi < 30 ? 'Oversold' : 'Neutral'})
    - Momentum: ${(tech.momentum * 100).toFixed(2)}%
    - Price Position: ${tech.pricePosition.toFixed(1)}% of daily range
    - Candlestick: ${tech.candlestickPattern}
    - Volatility: ${tech.volatility.toFixed(2)}%
    - Gap: ${tech.gapPercent.toFixed(2)}%`;
                }).join('\n\n');
                
                modelInputPreview.textContent = previewData + '\n\n... (22 more stocks with similar technical analysis data)';
            }
            
            async performAIAnalysisWithDetails() {
                document.getElementById('step4').style.display = 'block';
                const aiReasoning = document.getElementById('aiReasoning');
                
                aiReasoning.innerHTML = '<p>Preparing data for AI model...</p>';
                
                const stockDataArray = Object.values(this.stockData);
                
                if (stockDataArray.length === 0) {
                    throw new Error('No stock data available');
                }
                
                // Prepare data for AI analysis with technical indicators
                const marketSummary = stockDataArray.map(stock => {
                    const tech = stock.technical;
                    return `${stock.symbol} (${stock.name}):
  Price: $${stock.price.toFixed(2)} (${stock.changePercent > 0 ? '+' : ''}${stock.changePercent.toFixed(2)}%)
  Volume: ${stock.volume.toLocaleString()} (${tech.volumeIntensity})
  Technical Analysis:
    - RSI: ${tech.rsi.toFixed(1)} (${tech.rsi > 70 ? 'Overbought' : tech.rsi < 30 ? 'Oversold' : 'Neutral'})
    - Momentum: ${(tech.momentum * 100).toFixed(2)}%
    - Price Position: ${tech.pricePosition.toFixed(1)}% of daily range
    - Candlestick: ${tech.candlestickPattern}
    - Volatility: ${tech.volatility.toFixed(2)}%
    - Gap: ${tech.gapPercent.toFixed(2)}%`;
                }).join('\n\n');
                
                const prompt = `As an expert ETF analyst, analyze these 10 popular ETFs and predict which is most likely to have a positive day. Use the comprehensive technical analysis data provided.

ETF DATA WITH TECHNICAL INDICATORS:
${marketSummary}

Evaluation Criteria:
1. **Technical Momentum**: RSI levels, price momentum, gap analysis
2. **Volume Analysis**: Volume intensity and price/volume relationship  
3. **Candlestick Patterns**: Bullish/bearish signals from intraday action
4. **Price Action**: Position within daily range, volatility assessment
5. **Risk/Reward**: Balance potential upside with volatility risk

For each ETF, provide a prediction score from 1-100 (higher = more likely positive) based on:
- Strong technical indicators (RSI 30-70 range preferred)
- Positive momentum with reasonable volatility
- Bullish candlestick patterns
- Healthy volume levels
- Favorable price positioning

Respond in JSON format:
{
  "predictions": [
    {"symbol": "SPY", "score": 85, "reasoning": "Strong bullish momentum with RSI at 65, high volume confirms trend..."},
    ...
  ],
  "topPick": "SPY",
  "marketOutlook": "Overall ETF market technical analysis summary"
}`;

                aiReasoning.innerHTML = '<p>Sending data to AI model and waiting for analysis...</p>';

                const response = await this.engine.chat.completions.create({
                    messages: [{ role: 'user', content: prompt }],
                    temperature: 0.3,
                    max_tokens: 2000,
                });
                
                const analysisText = response.choices[0].message.content;
                let analysis;
                
                // Show the raw AI response
                aiReasoning.innerHTML = `
                    <h5>AI Model Response:</h5>
                    <p>The AI model has completed its analysis. Here's the reasoning process:</p>
                    <div class="raw-response">${analysisText}</div>
                `;
                
                try {
                    // Debug: Log AI response for troubleshooting
                    console.log('Raw AI Response:', analysisText);
                    
                    // Try multiple JSON extraction methods
                    let jsonMatch = analysisText.match(/\{[\s\S]*\}/);
                    
                    if (!jsonMatch) {
                        // Try alternative JSON patterns
                        jsonMatch = analysisText.match(/```json\n([\s\S]*?)\n```/);
                        if (jsonMatch) jsonMatch[0] = jsonMatch[1];
                    }
                    
                    if (!jsonMatch) {
                        // Try finding JSON within markdown code blocks
                        jsonMatch = analysisText.match(/```([\s\S]*?)```/);
                        if (jsonMatch) jsonMatch[0] = jsonMatch[1];
                    }
                    
                    if (jsonMatch) {
                        // Clean the JSON string
                        let jsonString = jsonMatch[0].trim();
                        
                        // Remove any markdown formatting
                        jsonString = jsonString.replace(/^```json\n?/, '').replace(/\n?```$/, '');
                        
                        console.log('Extracted JSON string:', jsonString);
                        
                        analysis = JSON.parse(jsonString);
                        
                        // Validate the analysis structure
                        if (!analysis.predictions || !Array.isArray(analysis.predictions)) {
                            throw new Error('Invalid analysis structure: missing predictions array');
                        }
                        
                        // Add parsed analysis summary
                        aiReasoning.innerHTML += `
                            <h5>✅ Parsed Analysis Results:</h5>
                            <p><strong>Top Pick:</strong> ${analysis.topPick}</p>
                            <p><strong>Market Outlook:</strong> ${analysis.marketOutlook}</p>
                            <p><strong>Total Predictions:</strong> ${analysis.predictions.length} stocks analyzed</p>
                        `;
                    } else {
                        throw new Error('No JSON found in response');
                    }
                } catch (parseError) {
                    console.error('Failed to parse AI response:', parseError);
                    console.error('AI Response Text:', analysisText);
                    
                    // Fallback: create basic analysis
                    analysis = this.createFallbackAnalysis(stockDataArray);
                    
                    aiReasoning.innerHTML += `
                        <h5>⚠️ Fallback Analysis Used:</h5>
                        <p>AI response parsing failed: ${parseError.message}</p>
                        <p>Using technical analysis fallback algorithm instead.</p>
                        <details>
                            <summary>Click to see raw AI response</summary>
                            <pre style="font-size: 0.7rem; max-height: 200px; overflow-y: auto;">${analysisText}</pre>
                        </details>
                    `;
                }
                
                this.displayResults(analysis);
            }
            
            async fetchStockData() {
                // Get yesterday's date for end-of-day data
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                const dateStr = yesterday.toISOString().split('T')[0];
                
                let requestCount = 0;
                const maxRequests = 25; // Analyze all stocks
                
                for (const stock of TOP_STOCKS.slice(0, maxRequests)) {
                    try {
                        // Fetch current day data and previous close for technical analysis
                        const prevUrl = `https://api.polygon.io/v2/aggs/ticker/${stock.symbol}/prev?adjusted=true&apikey=${this.apiKey}`;
                        
                        console.log(`Fetching data for ${stock.symbol}...`);
                        const response = await fetch(prevUrl);
                        const data = await response.json();
                        
                        if (data.results && data.results.length > 0) {
                            const result = data.results[0];
                            const price = result.c; // Close price
                            const open = result.o; // Open price
                            const high = result.h; // High price
                            const low = result.l; // Low price
                            const volume = result.v; // Volume
                            
                            const change = price - open;
                            const changePercent = ((change / open) * 100);
                            
                            // Calculate technical indicators
                            const technical = this.calculateTechnicalIndicators({
                                open, high, low, close: price, volume
                            });
                            
                            this.stockData[stock.symbol] = {
                                symbol: stock.symbol,
                                name: stock.name,
                                price: price,
                                change: change,
                                changePercent: changePercent,
                                volume: volume,
                                high: high,
                                low: low,
                                open: open,
                                previousClose: price,
                                technical: technical
                            };
                            
                            console.log(`✓ ${stock.symbol}: $${price.toFixed(2)} (${changePercent > 0 ? '+' : ''}${changePercent.toFixed(2)}%) - RSI: ${technical.rsi.toFixed(1)}`);
                        }
                        
                        requestCount++;
                        
                        // Respect rate limits - wait 12 seconds between requests (5 requests/minute)
                        if (requestCount < maxRequests) {
                            await new Promise(resolve => setTimeout(resolve, 12000));
                        }
                        
                    } catch (error) {
                        console.error(`Error fetching ${stock.symbol}:`, error);
                    }
                }
                
                console.log(`Fetched data for ${Object.keys(this.stockData).length} stocks`);
            }
            
            calculateTechnicalIndicators(ohlcv) {
                const { open, high, low, close, volume } = ohlcv;
                
                // Calculate basic technical indicators
                const bodySize = Math.abs(close - open);
                const shadowSize = high - low;
                const upperShadow = high - Math.max(open, close);
                const lowerShadow = Math.min(open, close) - low;
                
                // Simple RSI approximation (normally needs 14 periods)
                // Using single day momentum as proxy
                const momentum = (close - open) / open;
                const rsi = 50 + (momentum * 100); // Simplified RSI
                
                // Volume analysis
                const volumeIntensity = volume > 1000000 ? 'High' : volume > 500000 ? 'Medium' : 'Low';
                
                // Price position within day's range
                const pricePosition = shadowSize > 0 ? ((close - low) / shadowSize) * 100 : 50;
                
                // Candlestick pattern analysis
                let candlestickPattern = 'Neutral';
                const bodyPercent = shadowSize > 0 ? (bodySize / shadowSize) * 100 : 0;
                
                if (close > open) {
                    if (bodyPercent > 70) candlestickPattern = 'Strong Bullish';
                    else if (bodyPercent > 40) candlestickPattern = 'Bullish';
                    else candlestickPattern = 'Weak Bullish';
                } else if (close < open) {
                    if (bodyPercent > 70) candlestickPattern = 'Strong Bearish';
                    else if (bodyPercent > 40) candlestickPattern = 'Bearish';
                    else candlestickPattern = 'Weak Bearish';
                }
                
                // Gap analysis (compared to previous close approximation)
                const gapPercent = ((open - close) / close) * 100;
                
                return {
                    rsi: Math.max(0, Math.min(100, rsi)),
                    momentum: momentum,
                    volumeIntensity: volumeIntensity,
                    pricePosition: pricePosition,
                    candlestickPattern: candlestickPattern,
                    bodyPercent: bodyPercent,
                    gapPercent: gapPercent,
                    upperShadowPercent: shadowSize > 0 ? (upperShadow / shadowSize) * 100 : 0,
                    lowerShadowPercent: shadowSize > 0 ? (lowerShadow / shadowSize) * 100 : 0,
                    volatility: shadowSize / close * 100 // Daily volatility percentage
                };
            }
            
            async performAIAnalysis() {
                const stockDataArray = Object.values(this.stockData);
                
                if (stockDataArray.length === 0) {
                    throw new Error('No stock data available');
                }
                
                // Prepare data for AI analysis with technical indicators
                const marketSummary = stockDataArray.map(stock => {
                    const tech = stock.technical;
                    return `${stock.symbol} (${stock.name}):
  Price: $${stock.price.toFixed(2)} (${stock.changePercent > 0 ? '+' : ''}${stock.changePercent.toFixed(2)}%)
  Volume: ${stock.volume.toLocaleString()} (${tech.volumeIntensity})
  Technical Analysis:
    - RSI: ${tech.rsi.toFixed(1)} (${tech.rsi > 70 ? 'Overbought' : tech.rsi < 30 ? 'Oversold' : 'Neutral'})
    - Momentum: ${(tech.momentum * 100).toFixed(2)}%
    - Price Position: ${tech.pricePosition.toFixed(1)}% of daily range
    - Candlestick: ${tech.candlestickPattern}
    - Volatility: ${tech.volatility.toFixed(2)}%
    - Gap: ${tech.gapPercent.toFixed(2)}%`;
                }).join('\n\n');
                
                const prompt = `As an expert ETF analyst, analyze these 10 popular ETFs and predict which is most likely to have a positive day. Use the comprehensive technical analysis data provided.

ETF DATA WITH TECHNICAL INDICATORS:
${marketSummary}

Evaluation Criteria:
1. **Technical Momentum**: RSI levels, price momentum, gap analysis
2. **Volume Analysis**: Volume intensity and price/volume relationship  
3. **Candlestick Patterns**: Bullish/bearish signals from intraday action
4. **Price Action**: Position within daily range, volatility assessment
5. **Risk/Reward**: Balance potential upside with volatility risk

For each ETF, provide a prediction score from 1-100 (higher = more likely positive) based on:
- Strong technical indicators (RSI 30-70 range preferred)
- Positive momentum with reasonable volatility
- Bullish candlestick patterns
- Healthy volume levels
- Favorable price positioning

Respond in JSON format:
{
  "predictions": [
    {"symbol": "SPY", "score": 85, "reasoning": "Strong bullish momentum with RSI at 65, high volume confirms trend..."},
    ...
  ],
  "topPick": "SPY",
  "marketOutlook": "Overall ETF market technical analysis summary"
}`;

                const response = await this.engine.chat.completions.create({
                    messages: [{ role: 'user', content: prompt }],
                    temperature: 0.3,
                    max_tokens: 2000,
                });
                
                const analysisText = response.choices[0].message.content;
                let analysis;
                
                try {
                    // Extract JSON from response
                    const jsonMatch = analysisText.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        analysis = JSON.parse(jsonMatch[0]);
                    } else {
                        throw new Error('No JSON found in response');
                    }
                } catch (parseError) {
                    console.error('Failed to parse AI response:', parseError);
                    // Fallback: create basic analysis
                    analysis = this.createFallbackAnalysis(stockDataArray);
                }
                
                this.displayResults(analysis);
            }
            
            createFallbackAnalysis(stockDataArray) {
                // Enhanced technical analysis scoring as fallback
                const predictions = stockDataArray.map(stock => {
                    let score = 50; // Base score
                    const tech = stock.technical;
                    
                    // RSI scoring (prefer 30-70 range)
                    if (tech.rsi >= 30 && tech.rsi <= 70) score += 15;
                    else if (tech.rsi < 30) score += 25; // Oversold can be bullish
                    else score -= 10; // Overbought is bearish
                    
                    // Momentum scoring
                    if (tech.momentum > 0) score += 20;
                    if (tech.momentum > 0.02) score += 10; // Strong positive momentum
                    
                    // Volume intensity
                    if (tech.volumeIntensity === 'High') score += 15;
                    else if (tech.volumeIntensity === 'Medium') score += 8;
                    
                    // Candlestick pattern scoring
                    if (tech.candlestickPattern.includes('Strong Bullish')) score += 20;
                    else if (tech.candlestickPattern.includes('Bullish')) score += 12;
                    else if (tech.candlestickPattern.includes('Bearish')) score -= 10;
                    
                    // Price position (prefer higher in range)
                    if (tech.pricePosition > 70) score += 10;
                    else if (tech.pricePosition < 30) score -= 5;
                    
                    // Volatility consideration (moderate volatility preferred)
                    if (tech.volatility > 5) score -= 5; // Too volatile
                    else if (tech.volatility < 1) score -= 3; // Too stagnant
                    
                    return {
                        symbol: stock.symbol,
                        score: Math.min(95, Math.max(5, score)),
                        reasoning: `${tech.candlestickPattern} pattern, RSI ${tech.rsi.toFixed(1)}, ${tech.volumeIntensity.toLowerCase()} volume, ${tech.momentum > 0 ? 'positive' : 'negative'} momentum`
                    };
                });
                
                // Sort by score and pick top
                predictions.sort((a, b) => b.score - a.score);
                
                return {
                    predictions,
                    topPick: predictions[0].symbol,
                    marketOutlook: 'ETF technical analysis based on RSI, momentum, volume, and candlestick patterns'
                };
            }
            
            displayResults(analysis) {
                this.stocksGrid.innerHTML = '';
                
                // Sort predictions by score
                const sortedPredictions = analysis.predictions.sort((a, b) => b.score - a.score);
                
                sortedPredictions.forEach((prediction, index) => {
                    const stock = this.stockData[prediction.symbol];
                    if (!stock) return;
                    
                    const card = document.createElement('div');
                    card.className = `stock-card ${index === 0 ? 'winner' : ''}`;
                    
                    const changeClass = stock.change >= 0 ? 'positive' : 'negative';
                    const changeSign = stock.change >= 0 ? '+' : '';
                    
                    let scoreClass = 'low';
                    if (prediction.score >= 70) scoreClass = 'high';
                    else if (prediction.score >= 50) scoreClass = 'medium';
                    
                    const tech = stock.technical;
                    const rsiClass = tech.rsi > 70 ? 'negative' : tech.rsi < 30 ? 'negative' : 'positive';
                    
                    card.innerHTML = `
                        ${index === 0 ? '<div class="winner-banner">TOP PICK</div>' : ''}
                        <div class="stock-symbol">${stock.symbol}</div>
                        <div class="stock-name">${stock.name}</div>
                        <div class="stock-price">$${stock.price.toFixed(2)}</div>
                        <div class="stock-change ${changeClass}">
                            ${changeSign}${stock.change.toFixed(2)} (${changeSign}${stock.changePercent.toFixed(2)}%)
                        </div>
                        <div style="font-size: 0.8rem; color: #666; margin: 10px 0; line-height: 1.3;">
                            <div>RSI: <span class="${rsiClass}">${tech.rsi.toFixed(1)}</span> | Vol: ${tech.volumeIntensity}</div>
                            <div>${tech.candlestickPattern} | Volatility: ${tech.volatility.toFixed(1)}%</div>
                        </div>
                        <div class="prediction-score">
                            <div class="prediction-label">AI Prediction Score</div>
                            <div class="prediction-value ${scoreClass}">${prediction.score}/100</div>
                        </div>
                    `;
                    
                    this.stocksGrid.appendChild(card);
                });
            }
        }

        // Initialize the stock analyzer when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.stockAnalyzer = new StockAnalyzer();
        });
    </script>
</body>
</html>